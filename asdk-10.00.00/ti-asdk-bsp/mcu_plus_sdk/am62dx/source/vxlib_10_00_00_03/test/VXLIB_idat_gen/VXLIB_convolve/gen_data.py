from __future__ import print_function
from subprocess import call
from sys import platform

import sys
import numpy as np
import csv
import scipy
from scipy import signal

sys.path.append("../common")
import VXLIB_utils
import file_io


def gen_testCaseParams(testParamsFile, currPrm):
    """Generate and write test case parameters to idat file

    Args:
        param1 (file object): Input file object to idat.c file
        param2 (dict object): Dict object with test case parameter

    """

    testId = currPrm["ID"]
    dTypeIn = currPrm["dTypeIn"]
    dTypeFilter = currPrm["dTypeFilter"]
    dTypeOut = currPrm["dTypeOut"]
    width = currPrm["width"]
    height = currPrm["height"]
    filterHeight = currPrm["filterHeight"]
    filterWidth = currPrm["filterWidth"]
    scale = currPrm["scale"]
    strideIn = currPrm["strideIn"]
    strideOut = currPrm["strideOut"]
    padLeft = currPrm["padLeft"]
    padRight = currPrm["padRight"]
    padTop = currPrm["padTop"]
    padBottom = currPrm["padBottom"]
    testType = currPrm["testType"]
    demoCase = currPrm["demoCase"]
    numReps = currPrm["numReps"]
    outputDataLocation = currPrm["outputDataLocation"]

    if testType == "STATIC":
        inp = "staticRefInCase" + testId
        filter = "staticRefFilterCase" + testId
        out = "staticRefOutCase" + testId
    else:
        inp = "NULL"
        filter = "NULL"
        out = "NULL"

    if demoCase == "true":
        testParamsFile.write(
            "#if (defined(ALL_TEST_CASES) || (TEST_CASE == %d) || defined(DEMO_CASE))\n"
            % (int(testId))
        )
    else:
        testParamsFile.write(
            "#if (defined(ALL_TEST_CASES) || (TEST_CASE == %d))\n" % (int(testId))
        )

    idatFile.write("{\n")
    idatFile.write("%s, // Test pattern \n" % ((testType)))
    idatFile.write("%s, // Input vector  \n" % ((inp)))
    idatFile.write(
        "%s, // data type in \n" % (VXLIB_utils.resolveVXLIBDType(dTypeIn))
    )
    idatFile.write("%s, // Convolution filter matrix \n" % ((filter)))
    idatFile.write(
        "%s, // data type filter \n" % (VXLIB_utils.resolveVXLIBDType(dTypeFilter))
    )
    idatFile.write("%s, // Output vector \n" % ((out)))
    idatFile.write(
        "%s, // data type out \n" % (VXLIB_utils.resolveVXLIBDType(dTypeOut))
    )
    idatFile.write("%d, // width of image \n" % ((width)))
    idatFile.write("%d, // height of image \n" % ((height)))
    idatFile.write("%d, // width of filter \n" % ((filterWidth)))
    idatFile.write("%d, // height of filter \n" % ((filterHeight)))
    idatFile.write("%d, // scale value of sum of products \n" % ((scale)))
    idatFile.write("%d* sizeof(%s), // strideIn \n" % ((strideIn), (dTypeIn)))
    idatFile.write("%d* sizeof(%s), // strideOut \n" % ((strideOut), (dTypeOut)))
    idatFile.write("%s, // padLeft \n" % ((padLeft)))
    idatFile.write("%s, // padRight \n" % ((padRight)))
    idatFile.write("%s, // padTop \n" % ((padTop)))
    idatFile.write("%s, // padBottom \n" % ((padBottom)))
    idatFile.write("%s, // Output data location \n" % (outputDataLocation))
    idatFile.write("%d, // number of reps. \n" % (int(numReps)))
    idatFile.write("%d, // test ID\n" % int(testId))
    idatFile.write("},\n")
    idatFile.write("#endif")
    idatFile.write("\n\n")


def gen_idat_file(idatFile, testCases):
    """Generate the idat file

    Args:
        param1 (file object): Input file object to idat.c file
        param2 (dict object): Dict object with test case parameter

    """

    fIn = open("../common/ti_lice_header_idat.txt", "r")
    lines = fIn.readlines()
    fIn.close()
    idatFile.writelines(lines)
    includeString = '#include "VXLIB_convolve_idat.h"'
    idatFile.writelines(includeString)
    idatFile.write("\n")
    idatFile.write("/*This file is autogenerated*/\n")
    idatFile.write("/*Please do not edit*/\n")
    idatFile.write("\n\n")
    # generate ifdefs for header files
    for testCase in testCases:
        if testCase["testType"] == "STATIC":
            VXLIB_utils.gen_ifdefs(idatFile, testCase)

    # generate parameters for test cases
    idatFile.write("static VXLIB_convolve_testParams_t testParams[] =  ")
    idatFile.write("{\n")

    for testCase in testCases:
        gen_testCaseParams(idatFile, testCase)

    idatFile.write("};\n\n")
    fIn = open("test_param_function.txt", "r")
    lines = fIn.readlines()

    idatFile.writelines(lines)


def process_test_case(testCase):
    """Convert str to int for necessary parameters

    Args:
        Param1(:obj: dict) : Dictionary object with test case parameters

    Returns:
        Obj: Dictionary object with necessary parameters converted to int

    """

    # print(testCase.keys())
    testCase["testId"] = int(testCase["ID"])
    testCase["width"] = int(testCase["width"])
    testCase["height"] = int(testCase["height"])
    testCase["filterHeight"] = int(testCase["filterHeight"])
    testCase["filterWidth"] = int(testCase["filterWidth"])
    testCase["scale"] = int(testCase["scale"])
    testCase["strideIn"] = int(testCase["strideIn"])
    testCase["strideOut"] = int(testCase["strideOut"])
    testCase["padLeft"] = int(testCase["padLeft"])
    testCase["padRight"] = int(testCase["padRight"])
    testCase["padTop"] = int(testCase["padTop"])
    testCase["padBottom"] = int(testCase["padBottom"])

    return testCase


def gen_test_case_header_file(testCase):
    """Generate test case and write out input, filter, and output tensor
    into a header file usable in C/C++ code.

    Args:
        param1 (:obj: dict): A dict object with all the test case
        parameters

    Returns:
        [int int]: Minimum and maximum value in output feature tensor

    """

    ##############################
    # Get test parameter of case #
    ##############################

    testId = testCase["ID"]
    width = testCase["width"]
    height = testCase["height"]
    scale = testCase["scale"]
    filterHeight = testCase["filterHeight"]
    filterWidth = testCase["filterWidth"]
    dTypeIn = testCase["dTypeIn"]
    dTypeFilter = testCase["dTypeFilter"]
    dTypeOut = testCase["dTypeOut"]
    padLeft = testCase["padLeft"]
    padRight = testCase["padRight"]
    padTop = testCase["padTop"]
    padBottom = testCase["padBottom"]
    strideIn = testCase["strideIn"]
    strideOut = testCase["strideOut"]

    [minValIn, maxValIn] = VXLIB_utils.resolveDTypeLimits(dTypeIn)
    # [minValFilter, maxValFilter] = VXLIB_utils.resolveDTypeLimits(dTypeFilter)
    [minValFilter, maxValFilter] = [-2,3]
    [minValOut, maxValOut] = VXLIB_utils.resolveDTypeLimits(dTypeOut)

    
    inp = np.random.uniform(low=minValIn, high=maxValIn, size=(height, width)).astype(
        np.int64
    )

    convFilter = np.random.uniform(low=minValFilter, high=maxValFilter, size=(filterHeight, filterWidth)).astype(np.int64)

    
    isNotPadded = (padLeft == 0) and (padRight == 0) and (padTop == 0) and (padBottom == 0)
    
    if (isNotPadded):
        outHeight = height if (height < filterHeight) else height - filterHeight + 1
        outWidth = width if (width < filterWidth) else width - filterWidth + 1

    # TODO: calculate dimensions for padded corner cases
    else:
        outHeight = height
        outWidth = width

    out = np.zeros((outHeight, outWidth)).astype(VXLIB_utils.resolveNumpyDType(dTypeOut))
    
    # non-padded implementation
    if (isNotPadded):

        # use scipy library

        # use in mode=valid for non padded implementation
        out = signal.convolve2d(inp, convFilter, mode='valid')
        out = out >> scale;

        # saturate datatype
        out[out > maxValOut] = maxValOut
        out[out < minValOut] = minValOut
        
        # manual implementation
        
        # for i in range(outHeight):
        #     for j in range(outWidth):

        #         sum = np.int32(0)

        #         for m in range(filterHeight):
 
        #             for n in range(filterWidth):

        #                 if ((i+m < height) and (j+n < width)):
        #                     sum += np.int32(inp[i+m][j+n] * convFilter[filterHeight - m - 1][filterWidth - n - 1])

        #         result = np.int32(sum >> scale)

        #         # saturate values 
        #         result = maxValOut if result > maxValOut else result
        #         result = minValOut if result < minValOut else result
                
        #         out[i][j] = result
        
    # TODO: implementation with padding
    
    headerFileName = "staticRefCase" + str(testId) + ".h"
    file_io.write_header_file(inp, convFilter, out, testCase, headerFileName)
    
    return [np.min(out), np.max(out)]

# CSV file with paratmeters for all test cases
testCasesCsvFile = "test_cases_list.csv"
testIdList = range(1,86)  # list of test IDs that we want to generate test data

myArgs = VXLIB_utils.getCmdLineArgs()

def gen_test_case(testCase):
    if testCase["testType"] == "STATIC":
        [minY, maxY] = gen_test_case_header_file(testCase)
        print(
            "Test case generation completed for test ID",
            testCase["ID"],
            "w/ min:",
            minY,
            "and max",
            maxY,
        )
    else:
        print(
            "Skipping test case generation for test ID",
            testCase["ID"],
            "as tesType is RANDOM",
        )


#############################################################################
# Open CSV file with test cases and generate header file with test data for #
# test cases of interest; based on testIdList                               #
#############################################################################

with open(testCasesCsvFile, encoding="utf-8-sig") as csv_file:
    testCaseReader = csv.DictReader(csv_file)
    testCases = list(testCaseReader)

    for testCase in testCases:
        testCase = process_test_case(testCase)

    for testCase in testCases:
        if myArgs.allCases == True:
            gen_test_case(testCase)
        elif int(testCase["ID"]) in testIdList:
            gen_test_case(testCase)

idatFileName = "../../VXLIB_convolve/VXLIB_convolve_idat.c"


##########################################################################
# Generate idat.cpp file by parsing all the test cases in the CSV file # #
##########################################################################


with open(idatFileName, "w") as idatFile:
    gen_idat_file(idatFile, testCases)


if platform == "linux" or platform == "linux2":
    call(["clang-format", "-style=file", "-i", idatFileName])
    call(["indent", "-nut", "-i3", "-c55", "-l200", idatFileName])
    call(["rm", idatFileName + "~"])  # remove backup file


print("Idat file generation completed")
