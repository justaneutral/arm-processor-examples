from __future__ import print_function
from subprocess import call
from sys import platform

import sys
import numpy as np
import csv

sys.path.append("../common")
import VXLIB_utils
import file_io


def gen_testCaseParams(testParamsFile, currPrm):
    """Generate and write test case parameters to idat file

    Args:
        param1 (file object): Input file object to idat.c file
        param2 (dict object): Dict object with test case parameter

    """

    testId = currPrm["ID"]
    dType = currPrm["dType"]
    width = currPrm["width"]
    height = currPrm["height"]
    strideIn = currPrm["strideIn"]
    minVal = currPrm["minVal"]
    maxVal = currPrm["maxVal"]
    minCount = currPrm["minCount"]
    maxCount = currPrm["maxCount"]
    minLocCapacity = currPrm["minLocCapacity"]
    maxLocCapacity = currPrm["maxLocCapacity"]
    startX = currPrm["startX"]
    startY = currPrm["startY"]
    mode = currPrm["mode"]
    testType = currPrm["testType"]
    numReps = currPrm["numReps"]
    outputDataLocation = currPrm["outputDataLocation"]
    demoCase = currPrm["demoCase"]

    # dTypeOut = "uint8_t" if dTypeIn0 == "int16_t" else "int16_t"

    if testType == "STATIC":
        staticIn = "staticRefInCase" + testId
        staticMinVal = "staticRefMinValCase" + testId
        staticMaxVal = "staticRefMaxValCase" + testId
        staticMinCount = "staticRefMinCountCase" + testId
        staticMaxCount = "staticRefMaxCountCase" + testId
        staticMinLoc = "staticRefMinLocCase" + testId
        staticMaxLoc = "staticRefMaxLocCase" + testId
    else:
        staticIn = "NULL"
        staticMinVal = "NULL"
        staticMaxVal = "NULL"
        staticMinCount = "NULL"
        staticMaxCount = "NULL"
        staticMinLoc = "NULL"
        staticMaxLoc = "NULL"

    if demoCase == "true":
        testParamsFile.write(
            "#if (defined(ALL_TEST_CASES) || (TEST_CASE == %d) || defined(DEMO_CASE))\n"
            % (int(testId))
        )
    else:
        testParamsFile.write(
            "#if (defined(ALL_TEST_CASES) || (TEST_CASE == %d))\n" % (int(testId))
        )

    idatFile.write("{\n")
    idatFile.write("%s, // Test pattern \n" % ((testType)))
    idatFile.write("%s, // Input image \n" % ((staticIn)))
    idatFile.write(
        "%s, // data type in \n" % (VXLIB_utils.resolveVXLIBDType(dType))
    )
    idatFile.write("%s, // minVal \n" % ((staticMinVal)))
    idatFile.write("%s, // maxVal \n" % ((staticMaxVal)))
    idatFile.write("%s, // minCount \n" % ((staticMinCount)))
    idatFile.write("%s, // maxCount \n" % ((staticMaxCount)))
    idatFile.write("%s, // minLoc \n" % ((staticMinLoc)))
    idatFile.write("%s, // maxLoc \n" % ((staticMaxLoc)))
    idatFile.write("%s, // width \n" % ((width)))
    idatFile.write("%s, // height \n" % ((height)))
    idatFile.write(
        "%s * sizeof(%s), // stride of image \n" % ((strideIn), (dType))
    )
    idatFile.write("%s, // minVal \n" % ((minVal)))
    idatFile.write("%s, // maxVal \n" % ((maxVal)))
    idatFile.write("%s, // minCount \n" % ((minCount)))
    idatFile.write("%s, // maxCount \n" % ((maxCount)))
    idatFile.write("%s, // minLocCapacity \n" % ((minLocCapacity)))
    idatFile.write("%s, // maxLocCapacity \n" % ((maxLocCapacity)))
    idatFile.write("%s, // startX \n" % ((startX)))
    idatFile.write("%s, // startY \n" % ((startY)))
    idatFile.write("%s, // mode \n" % ((mode)))
    idatFile.write("%s, // Output data location \n" % (outputDataLocation))
    idatFile.write("%d, // number of reps. \n" % (int(numReps)))
    idatFile.write("%d, // test ID\n" % int(testId))
    idatFile.write("},\n")
    idatFile.write("#endif")
    idatFile.write("\n\n")


def gen_idat_file(idatFile, testCases):
    """Generate the idat file

    Args:
        param1 (file object): Input file object to idat.c file
        param2 (dict object): Dict object with test case parameter

    """

    fIn = open("../common/ti_lice_header_idat.txt", "r")
    lines = fIn.readlines()
    fIn.close()
    idatFile.writelines(lines)
    includeString = '#include "VXLIB_minMaxLoc_idat.h"'
    idatFile.writelines(includeString)
    idatFile.write("\n")
    idatFile.write("/*This file is autogenerated*/\n")
    idatFile.write("/*Please do not edit*/\n")
    idatFile.write("\n\n")
    # generate ifdefs for header files
    for testCase in testCases:
        if testCase["testType"] == "STATIC":
            VXLIB_utils.gen_ifdefs(idatFile, testCase)

    # generate parameters for test cases
    idatFile.write("static VXLIB_minMaxLoc_testParams_t testParams[] =  ")
    idatFile.write("{\n")

    for testCase in testCases:
        gen_testCaseParams(idatFile, testCase)

    idatFile.write("};\n\n")
    fIn = open("test_param_function.txt", "r")
    lines = fIn.readlines()

    idatFile.writelines(lines)


def process_test_case(testCase):
    """Convert str to int for necessary parameters

    Args:
        Param1(:obj: dict) : Dictionary object with test case parameters

    Returns:
        Obj: Dictionary object with necessary parameters converted to int

    """

    # print(testCase.keys())
    testCase["testId"] = int(testCase["ID"])
    testCase["width"] = int(testCase["width"])
    testCase["height"] = int(testCase["height"])
    testCase["strideIn"] = int(testCase["strideIn"])
    testCase["minVal"]   = int(testCase["minVal"])
    testCase["maxVal"]   = int(testCase["maxVal"])
    testCase["minCount"] = int(testCase["minCount"])
    testCase["maxCount"] = int(testCase["maxCount"])
    testCase["minLocCapacity"] = int(testCase["minLocCapacity"])
    testCase["maxLocCapacity"] = int(testCase["maxLocCapacity"])
    testCase["startX"] = int(testCase["startX"])
    testCase["startY"] = int(testCase["startY"])
    testCase["mode"] = int(testCase["mode"])

    return testCase


def gen_test_case_header_file(testCase):
    """Generate test case and write out input, filter, and output tensor
    into a header file usable in C/C++ code.

    Args:
        param1 (:obj: dict): A dict object with all the test case
        parameters

    Returns:
        [int int]: Minimum and maximum value in output feature tensor

    """

    ##############################
    # Get test parameter of case #
    ##############################

    testId = testCase["ID"]
    dType = testCase["dType"]
    height = testCase["height"]
    width = testCase["width"]
    minVal = testCase["minVal"]
    maxVal = testCase["maxVal"]
    minCount = testCase["minCount"]
    maxCount = testCase["maxCount"]
    minLocCapacity = testCase["minLocCapacity"]
    maxLocCapacity = testCase["maxLocCapacity"]
    startX = testCase["startX"]
    startY = testCase["startY"]

    if dType == "int8_t" or dType == "uint8_t":
        bits = 8
    elif dType == "int16_t" or dType == "uint16_t":
        bits = 16
    elif dType == "int32_t" or dType == "uint32_t":
        bits = 32
    else:
        bits = 64

    # unsigned integer
    if dType[0] == "u":
        numericMinVal = 0
        numericMaxVal = (2 ** bits) - 1
    else:
        numericMinVal = -(2 ** (bits - 1))
        numericMaxVal = (2 ** (bits - 1)) - 1

    if dType == "uint8_t":
        in0 = np.random.uniform(low=numericMinVal, high=numericMaxVal, size=(height, width)).astype("uint8")
    elif dType == "int8_t":
        in0 = np.random.uniform(low=numericMinVal, high=numericMaxVal, size=(height, width)).astype("int8")
    elif dType == "uint16_t":
        in0 = np.random.uniform(low=numericMinVal, high=numericMaxVal, size=(height, width)).astype("uint16")
    elif dType == "int16_t":
        in0 = np.random.uniform(low=numericMinVal, high=numericMaxVal, size=(height, width)).astype("int16")
        

    # print(in0)
    minVal = np.minimum((np.min(in0)), minVal)  
    maxVal = np.maximum((np.max(in0)), maxVal)
    # print(minVal, maxVal)
    minCount = minCount + np.count_nonzero(in0 == minVal)
    maxCount = maxCount + np.count_nonzero(in0 == maxVal)
    # print(minCount, maxCount)
    indices = np.where(in0 == minVal)
    indices_0_list = [x + startX for x in list(indices[0])]
    indices_1_list = [x + startY for x in list(indices[1])]
    merged_list = []
    for a, b in zip(indices_1_list, indices_0_list):
        merged_list.append(a)
        merged_list.append(b)
    minLoc = merged_list
    # print(minLoc)  
    indices = np.where(in0 == maxVal)
    indices_0_list = [x + startX for x in list(indices[0])]
    indices_1_list = [x + startY for x in list(indices[1])]
    merged_list = []
    for a, b in zip(indices_1_list, indices_0_list):
        merged_list.append(a)
        merged_list.append(b)
    maxLoc = merged_list
    # print(maxLoc)



    headerFileName = "staticRefCase" + str(testId) + ".h"
    file_io.write_header_file(in0, minVal, maxVal, minCount, maxCount, minLoc, maxLoc, testCase, headerFileName)

    return [np.min(in0), np.max(in0)]


# CSV file with paratmeters for all test cases
testCasesCsvFile = "test_cases_list.csv"
testIdList = []  # list of test IDs that we want to generate test data
testIdList += range(1, 200)
# testIdList += [44]


myArgs = VXLIB_utils.getCmdLineArgs()


def gen_test_case(testCase):
    if testCase["testType"] == "STATIC":
        [minY, maxY] = gen_test_case_header_file(testCase)
        print(
            "Test case generation completed for test ID",
            testCase["ID"],
            "w/ min:",
            minY,
            "and max",
            maxY,
        )
    else:
        print(
            "Skipping test case generation for test ID",
            testCase["ID"],
            "as tesType is RANDOM",
        )


#############################################################################
# Open CSV file with test cases and generate header file with test data for #
# test cases of interest; based on testIdList                               #
#############################################################################

with open(testCasesCsvFile, encoding="utf-8-sig") as csv_file:
    testCaseReader = csv.DictReader(csv_file)
    testCases = list(testCaseReader)

    for testCase in testCases:
        testCase = process_test_case(testCase)

    for testCase in testCases:
        if myArgs.allCases == True:
            gen_test_case(testCase)
        elif int(testCase["ID"]) in testIdList:
            gen_test_case(testCase)

idatFileName = "../../VXLIB_minMaxLoc/VXLIB_minMaxLoc_idat.c"


##########################################################################
# Generate idat.cpp file by parsing all the test cases in the CSV file # #
##########################################################################


with open(idatFileName, "w") as idatFile:
    gen_idat_file(idatFile, testCases)


if platform == "linux" or platform == "linux2":
    call(["clang-format", "-style=file", "-i", idatFileName])
    call(["indent", "-nut", "-i3", "-c55", "-l200", idatFileName])
    call(["rm", idatFileName + "~"])  # remove backup file


print("Idat file generation completed")
