<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM62D FreeRTOS SDK: Booting Tools</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM62D FreeRTOS SDK
   &#160;<span id="projectnumber">10.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('TOOLS_BOOT.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Booting Tools </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1166">Introduction</a></li>
<li class="level1"><a href="#autotoc_md1167">Important files and folders</a></li>
<li class="level1"><a href="#autotoc_md1168">Out2RPRC</a></li>
<li class="level1"><a href="#autotoc_md1169">Multi-core Image Gen</a></li>
<li class="level1"><a href="#TOOLS_BOOT_SIGNING">Signing Scripts</a></li>
<li class="level1"><a href="#UART_BOOTLOADER_PYTHON_SCRIPT">UART Bootloader Python Script</a></li>
<li class="level1"><a href="#HSM_APPIMAGE_GEN_TOOL">HSM Appimage Generator Tool</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_components_tools_tools_boot"></a></p>
<dl class="section note"><dt>Note</dt><dd>To see the exact sequence of steps in which applications and secondary bootloader (SBL) are converted from compiler generated .out files to boot images, see the makefile <code>makefile_ccs_bootimage_gen</code> that is included in every example and secondary bootloader (SBL) CCS project.</dd>
<dd>
If you are using makefile based build, then see the file named <code>makefile</code> in the example folder.</dd></dl>
<h1><a class="anchor" id="autotoc_md1166"></a>
Introduction</h1>
<p>This section describes the various tools that are used to create boot images for all the SDK applications</p>
<h1><a class="anchor" id="autotoc_md1167"></a>
Important files and folders</h1>
<table class="doxtable">
<tr>
<th>Folder/Files </th><th>Description  </th></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/tools/boot/ </td></tr>
<tr>
<td>multicoreImageGen/ </td><td>Tool to combine multiple RPRC into a single binary  </td></tr>
<tr>
<td>out2rprc/ </td><td>Tool to convert compiler generated ELF .out for a CPU to a compact and loadable binary representation, called RPRC.  </td></tr>
<tr>
<td>sbl_prebuilt/ </td><td>Pre-built secondary bootloader (SBL) images and flash configuration files for different supported EVMs, see also <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a>  </td></tr>
<tr>
<td>signing/ </td><td>Security signing scripts need to create boot images that can be booted by ROM bootloader (RBL)  </td></tr>
<tr>
<td>xipGen/ </td><td>Tool to split a RPRC file generated from <code>out2rprc</code> into two files containing non-XIP and XIP sections.  </td></tr>
<tr>
<td>uart_bootloader.py </td><td>Python script used to send the SBL and appimage binaries over UART using XMODEM protocol in UART boot mode  </td></tr>
<tr>
<td>uart_uniflash.py </td><td>Python script used to flash SBL and applications to EVM flash using UART. See <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a> for more details.  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md1168"></a>
Out2RPRC</h1>
<ul>
<li>This tool converts the application executable (.out) into custom TI RPRC (.rprc) image - an image loadable by the secondary bootloader (SBL).</li>
<li>This tool strips out the initialized sections from the executable file (*.out) and places them in a compact format that the SBL can understand.</li>
<li>The output RPRC file is typically much smaller than the original executable (*.out) file.</li>
<li>The RPRC files are intermediate files in a format that is consumed by <code>MulticoreImageGen</code> tool that generates the final binary that is flashed (<code>*.appimage</code>)</li>
<li>The RPRC file format contains header to various sections in the executable like section run address, size and a overall header which mentions the number of sections and the start offset to the first section.</li>
<li>The RPRC magic word is <code>0x43525052</code> - which is ASCII equivalent for <code>RPRC</code></li>
<li>Shown below is the file header and section format for RPRC files.</li>
</ul>
<p> <style>div.image img[src="tools_rprc_format.png"]{width:40%}</style> </p><div class="image">
<img src="tools_rprc_format.png" alt=""/>
<div class="caption">
RPRC File Format</div></div>
<ul>
<li>This tool is provided as a minified JS script. To convert the application executable into RPRC image file, it can be used as <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/out2rprc</div>
<div class="line">${NODE} elf2rprc.js {input application executable file (.out)}</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md1169"></a>
Multi-core Image Gen</h1>
<ul>
<li>This tool converts the RPRC files created for each CPU into a single combined multicore application image that can be booted by the secondary bootloader (SBL)</li>
<li>Shown below is the file format for multicore image files.</li>
</ul>
<p> <style>div.image img[src="tools_multicore_format.png"]{width:60%}</style> </p><div class="image">
<img src="tools_multicore_format.png" alt=""/>
<div class="caption">
Multi-core Image File Format</div></div>
<ul>
<li>The number of meta headers present is equal to the number of cores included.</li>
<li>The meta header magic word is <code>0x5254534D</code> - which is ASCII equivalent for <code>MSTR</code></li>
<li>In Windows or Linux, use the following command to convert RPRC images into a multicore <code>.appimage</code> file <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/multicoreImageGen</div>
<div class="line">${NODE} multicoreImageGen.js --devID {DEV_ID} --out {Output image file (.appimage)} {core 1 rprc file}@{core 1 id} [ {core n rprc file}@{core n id} ... ]</div>
</div><!-- fragment --></li>
<li>In case of AM62DX, <code>DEV_ID</code> is <code>55</code>.</li>
<li>The various core ID to be used are as below.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">CORE  </th><th class="markdownTableHeadNone">CORE ID   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">r5fss0-0  </td><td class="markdownTableBodyNone">4   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mcu-r5fss0-0  </td><td class="markdownTableBodyNone">5   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">hsm-m4fss0-0  </td><td class="markdownTableBodyNone">6   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">c75ss0-0  </td><td class="markdownTableBodyNone">7   </td></tr>
</table>
<h1><a class="anchor" id="TOOLS_BOOT_SIGNING"></a>
Signing Scripts</h1>
<ul>
<li>To run these scripts, one needs <code>openssl</code> installed as mentioned here, <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_OPENSSL">OpenSSL</a></li>
<li>Signing scripts are a collection of scripts needed to sign ROM images (image booted by ROM - mostly the SBL) and application images (image booted by the SBL)</li>
<li>The RBL requires the boot image (mostly SBL), to be signed always, even if we are not using secure boot.</li>
<li>We follow a combined boot method for ROM images. Here the ROM Bootloader (RBL) boots the SBL, SYSFW and BOARDCFG together. The boot image would be a binary concatenation of x509 Certificate, SBL, SYSFW, BOARDCFG (and the SYSFW inner certificate in case of HS device) binary blobs. We use a python script to generate this final boot image. This script has a dependency on <code>openssl</code> as mentioned before, so make sure you've installed it. To generate a combined boot image, one can do as below:</li>
<li>For GP devices <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/signing</div>
<div class="line">${PYTHON} rom_image_gen.py --swrv 1 --sbl-bin  &lt;path-to-sbl-binary&gt; --sysfw-bin &lt;path-to-sysfw-binary&gt; --boardcfg-blob &lt;path-to-boardcfg-binary-blob&gt; --boardcfg-sbldata-blob &lt;path-to-boardcfg-sbldata-blob&gt; --sbl-loadaddr ${SBL_RUN_ADDRESS} --sysfw-loadaddr ${SYSFW_LOAD_ADDR} --bcfg-loadaddr ${BOARDCFG_LOAD_ADDR} --bcfg-sbldata-loadaddr ${BOARDCFG_SBLDATA_LOAD_ADDR} --key ${BOOTIMAGE_CERT_KEY} --rom-image &lt;path-to-output-image&gt; --enable-sbldata yes</div>
</div><!-- fragment --></li>
<li>For HS devices, we have to pass the HS SYSFW binaries and also the SYSFW inner certificate to the signing script. <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/signing</div>
<div class="line">${PYTHON} rom_image_gen.py --swrv 1 --sbl-bin &lt;path-to-sbl-binary&gt; --sysfw-bin &lt;path-to-sysfw-binary&gt; --sysfw-inner-cert &lt;path-to-sysfw-inner-cert-binary&gt; --boardcfg-blob &lt;path-to-boardcfg-binary-blob&gt; --boardcfg-sbldata-blob &lt;path-to-boardcfg-sbldata-blob&gt; --sbl-loadaddr ${SBL_RUN_ADDRESS} --sysfw-loadaddr ${SYSFW_LOAD_ADDR} --bcfg-loadaddr ${BOARDCFG_LOAD_ADDR} --bcfg-sbldata-loadaddr ${BOARDCFG_SBLDATA_LOAD_ADDR} --key ${BOOTIMAGE_CERT_KEY} --rom-image &lt;path-to-output-image&gt; --enable-sbldata yes</div>
</div><!-- fragment --></li>
<li>For SBL images or examples which is loaded by SBL, we use a different signing script. This is solely because of the x509 certificate template differences between ROM and SYSFW. In GP devices appimages are not signed. The signing happens only in HS devices. The script usage is: <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/signing</div>
<div class="line">$(PYTHON) appimage_x509_cert_gen.py --bin &lt;path-to-the-binary&gt; --authtype 0 --loadaddr 84000000 --key &lt;signing-key-derived-from-devconfig&gt; --output &lt;output-image-name&gt; --keyversion 1.5</div>
</div><!-- fragment --></li>
<li>In the case of encryption, two extra options are also passed to the script like so: <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/signing</div>
<div class="line">$(PYTHON) appimage_x509_cert_gen.py --bin &lt;path-to-the-binary&gt; --authtype 0 --loadaddr 84000000 --key &lt;signing-key-derived-from-devconfig&gt; --enc y --enckey &lt;encryption-key-derived-from-devconfig&gt; --output &lt;output-image-name&gt; --keyversion 1.5</div>
</div><!-- fragment --></li>
<li>These scripts are invoked in makefiles, and the image generation happens automatically along with the example build. So mostly these scripts need not be manually run.<ul>
<li>Here,<ul>
<li><code>SBL_RUN_ADDRESS</code> is <code>0x43C00000</code></li>
<li>In the case of GP device, <code>BOOTIMAGE_CERT_KEY</code> is <code>app_degenerateKey.pem</code></li>
<li>In the case of HS device, <code>BOOTIMAGE_CERT_KEY</code> is custMpk_am62dx .pem.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>For more details about this see <a class="el" href="SECURE_BOOT.html">Enabling Secure Boot</a></p>
<p>These scripts are invoked in makefiles, and the image generation happens automatically along with the example build. So mostly these scripts need not be manually run. If the user build-system is different from TI's makefile system, it needs to be ensured that the same is followed as part of the post build steps. The devconfig has ENC_SBL_ENABLED=yes and that is why for HS-SE devices, the SBL image is encrypted by default.</p>
<h1><a class="anchor" id="UART_BOOTLOADER_PYTHON_SCRIPT"></a>
UART Bootloader Python Script</h1>
<ul>
<li>This script is used in UART boot mode for sending the SBL and appimage binaries to the EVM via UART using XMODEM protocol</li>
<li>Make sure that python3 and its dependent modules are installed in the host machine as mentioned in <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a></li>
<li>Booting via UART is slow, but is useful if application loading via CCS or OSPI boot is not an option</li>
<li>Make sure the UART port used for terminal is identified as mentioned in <a class="el" href="EVM_SETUP_PAGE.html#CCS_UART_TERMINAL">Setup UART Terminal</a></li>
<li>Make sure you have the EVM power cable and UART cable connected as shown in <a class="el" href="EVM_SETUP_PAGE.html#EVM_CABLES">Cable Connections</a></li>
<li>To boot applications using this script, <b>POWER OFF the EVM</b></li>
<li>Switch to <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_UART">UART BOOT MODE</a>.</li>
<li><b>POWER ON the EVM</b></li>
<li>To confirm that the board is in UART boot mode, open the UART terminal and confirm that you see the character 'C' getting printed on the console every 2-3 seconds.</li>
<li>Now close the terminal. This is important as the script won't be able to function properly if the UART terminal is open.</li>
<li>Update the appimage path on sbl_prebuilt/{board}/default_sbl_uart_hs_fs.cfg file</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>For HS-SE device, use default_sbl_uart_hs.cfg as the cfg file.</dd></dl>
<ul>
<li>Open a command prompt and run the below command to send the SBL and application binary to the EVM<ul>
<li>on Linux <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot</div>
<div class="line">python uart_bootloader.py -p /dev/ttyUSB0 --cfg=sbl_prebuilt/{board}/default_sbl_uart_hs_fs.cfg</div>
</div><!-- fragment --></li>
<li>on Windows <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot</div>
<div class="line">python uart_bootloader.py -p -p COM&lt;x&gt; --cfg=sbl_prebuilt/{board}/default_sbl_uart_hs_fs.cfg</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>When you execute this, the script first sends the uart bootloader, and then the multicore appimage</li>
<li>After the multicore appimage is successfully parsed, the uart bootloader sends an acknowledgment to the script and waits for 5 seconds before running the application binary</li>
<li>Upon receiving the ack, the script will exit successfully</li>
<li>Connect to the UART terminal within 5 seconds to see logs from the application</li>
<li>Below are the logs of the script after all the files have been sent <div class="fragment"><div class="line">Sending the UART bootloader sbl_prebuilt/{board}/sbl_uart.release.tiimage ...</div>
<div class="line">Sent bootloader sbl_prebuilt/{board}/sbl_uart.release.tiimage of size 243975 bytes in 23.94s.</div>
<div class="line"> </div>
<div class="line">Sending the application ../../examples/drivers/udma/udma_memcpy_polling/{board}/r5fss0-0_nortos/ti-arm-clang/udma_memcpy_polling.release.appimage ...</div>
<div class="line">Sent application ../../examples/drivers/udma/udma_memcpy_polling/{board}/r5fss0-0_nortos/ti-arm-clang/udma_memcpy_polling.release.appimage of size 99580 bytes in 11.74s.</div>
<div class="line">[STATUS] Application load SUCCESS !!!</div>
<div class="line">Connect to UART in 5 seconds to see logs from UART !!!</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="HSM_APPIMAGE_GEN_TOOL"></a>
HSM Appimage Generator Tool</h1>
<dl class="section note"><dt>Note</dt><dd>Change DEVICE_TYPE to HS in ${SDK_INSTALL_PATH}/devconfig/devconfig.mak and then generate Linux Appimage for HS-SE device.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>GCC AARCH64 compiler installation is required for HSM appimage generation. Refer <a class="el" href="SDK_DOWNLOAD_PAGE.html#GCC_AARCH64_DOWNLOAD">GCC AARCH64 Compiler</a></dd></dl>
<ul>
<li>This tool generates a HSM Appimage by taking the HSM binaries (.bin file) as input and generates an appimage containing the input HSM binary.</li>
<li>The input file location can be mentioned in the <code>config.mak</code> file located at {SDK_INSTALL_PATH}/tools/boot/HSMAppimageGen/board/am62dx-evm</li>
<li>The input file name for HSM bin file can be mentioned in the <code>config.mak</code> file.<ul>
<li><code>#Input binary name</code><br  />
 <code>HSM_BINARY_NAME = HSM_min_sample.bin</code><br  />
</li>
</ul>
</li>
<li>The output appimage name can be mentioned in the <code>config.mak</code> file.<ul>
<li><code>#Output appimage name</code><br  />
 <code>HSM_APPIMAGE_NAME=hsm.appimage</code><br  />
</li>
</ul>
</li>
<li>Run the makefile at {SDK_INSTALL_PATH}/tools/boot/HSMAppimageGen to generate the HSM appimage<ul>
<li>For Windows <pre class="fragment">  cd ${SDK_INSTALL_PATH}/tools/boot/HSMAppimageGen
  gmake -s BOARD=am62dx-evm all
</pre></li>
<li>For Linux <pre class="fragment">  cd ${SDK_INSTALL_PATH}/tools/boot/HSMAppimageGen
  make -s BOARD=am62dx-evm all
</pre></li>
</ul>
</li>
<li>The HSM appimage wil be generated at {SDK_INSTALL_PATH}/tools/boot/HSMAppimageGen/board/am62dx-evm after running the makefile </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
