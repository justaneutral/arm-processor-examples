<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AWE Core 8.X.0 Documentation: Include/AWEInstance.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AWE Core 8.X.0 Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_856524284ebe840938865dc061f982fb.html">Include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">AWEInstance.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The AWEInstance API Header File.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &quot;TargetProcessor.h&quot;</code><br />
</div>
<p><a href="a00044_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html">_AWEInstance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The AWE instance.  <a href="a00071.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00075.html">AWEBuildVersionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build versioning structure returned by <a class="el" href="a00044.html#a3b968559431299090c6c96e1e271ac15">awe_getBuildVersionInfo</a>.  <a href="a00075.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af3b70df7f9d672997e61999a024ba018"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a00071.html">_AWEInstance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a></td></tr>
<tr class="memdesc:af3b70df7f9d672997e61999a024ba018"><td class="mdescLeft">&#160;</td><td class="mdescRight">The AWE instance.  <a href="a00044.html#af3b70df7f9d672997e61999a024ba018">More...</a><br /></td></tr>
<tr class="separator:af3b70df7f9d672997e61999a024ba018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae753d7bd23dd29879d2732b0609cb4df"><td class="memItemLeft" align="right" valign="top"><a id="ae753d7bd23dd29879d2732b0609cb4df" name="ae753d7bd23dd29879d2732b0609cb4df"></a>
typedef struct <a class="el" href="a00075.html">AWEBuildVersionInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AWEBuildVersionInfo_t</b></td></tr>
<tr class="memdesc:ae753d7bd23dd29879d2732b0609cb4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build versioning structure returned by <a class="el" href="a00044.html#a3b968559431299090c6c96e1e271ac15">awe_getBuildVersionInfo</a>. <br /></td></tr>
<tr class="separator:ae753d7bd23dd29879d2732b0609cb4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2378b78800142dc746b4abbf1b1717ac"><td class="memItemLeft" align="right" valign="top"><a id="a2378b78800142dc746b4abbf1b1717ac" name="a2378b78800142dc746b4abbf1b1717ac"></a>
typedef INT32&#160;</td><td class="memItemRight" valign="bottom"><b>packetProcessFunction</b>(<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE)</td></tr>
<tr class="separator:a2378b78800142dc746b4abbf1b1717ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae4e7e278a5a4794714190415899d8022"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ae4e7e278a5a4794714190415899d8022">awe_init</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE)</td></tr>
<tr class="memdesc:ae4e7e278a5a4794714190415899d8022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the instance.  <a href="a00044.html#ae4e7e278a5a4794714190415899d8022">More...</a><br /></td></tr>
<tr class="separator:ae4e7e278a5a4794714190415899d8022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d7c4aef91a7b0e190881efa67d15a7"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a20d7c4aef91a7b0e190881efa67d15a7">awe_initPin</a> (IOPinDescriptor *pPin, UINT32 channels, const char *name)</td></tr>
<tr class="memdesc:a20d7c4aef91a7b0e190881efa67d15a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an input or output pin.  <a href="a00044.html#a20d7c4aef91a7b0e190881efa67d15a7">More...</a><br /></td></tr>
<tr class="separator:a20d7c4aef91a7b0e190881efa67d15a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985924707ad2ac0c06eb792702783087"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a985924707ad2ac0c06eb792702783087">awe_initFlashFS</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, <a class="el" href="a00053.html#ae8ec7ae5a5cf8b4417f114378458ef3f">AWEFlashFSInstance</a> *pAWEFlashFSInstance)</td></tr>
<tr class="memdesc:a985924707ad2ac0c06eb792702783087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the file system.  <a href="a00044.html#a985924707ad2ac0c06eb792702783087">More...</a><br /></td></tr>
<tr class="separator:a985924707ad2ac0c06eb792702783087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e9b6fa73ef4217ac60c80e7cb75b53"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ad4e9b6fa73ef4217ac60c80e7cb75b53">awe_packetProcess</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE)</td></tr>
<tr class="memdesc:ad4e9b6fa73ef4217ac60c80e7cb75b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process an AWEInstance's newly received tuning packet.  <a href="a00044.html#ad4e9b6fa73ef4217ac60c80e7cb75b53">More...</a><br /></td></tr>
<tr class="separator:ad4e9b6fa73ef4217ac60c80e7cb75b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5438a02407ecb829c58faa4b2610f8"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a2d5438a02407ecb829c58faa4b2610f8">awe_packetProcessMulti</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, BOOL isTuningInstance)</td></tr>
<tr class="memdesc:a2d5438a02407ecb829c58faa4b2610f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-instance Wrapper for tuning packet processing.  <a href="a00044.html#a2d5438a02407ecb829c58faa4b2610f8">More...</a><br /></td></tr>
<tr class="separator:a2d5438a02407ecb829c58faa4b2610f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e08c72e3bf11627e4fd87a99ebb6419"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a3e08c72e3bf11627e4fd87a99ebb6419">awe_audioPump</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 layoutIndex)</td></tr>
<tr class="memdesc:a3e08c72e3bf11627e4fd87a99ebb6419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio pump function.  <a href="a00044.html#a3e08c72e3bf11627e4fd87a99ebb6419">More...</a><br /></td></tr>
<tr class="separator:a3e08c72e3bf11627e4fd87a99ebb6419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4bb98b017a47c1c1cad5e897c6390b"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a9e4bb98b017a47c1c1cad5e897c6390b">awe_audioImportSamples</a> (const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, const void *inSamples, INT32 inStride, INT32 channel, <a class="el" href="a00056.html#a2148c107244f027b63ea5fa4e55a582b">SampleType</a> inType)</td></tr>
<tr class="memdesc:a9e4bb98b017a47c1c1cad5e897c6390b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import samples from a user buffer to a channel.  <a href="a00044.html#a9e4bb98b017a47c1c1cad5e897c6390b">More...</a><br /></td></tr>
<tr class="separator:a9e4bb98b017a47c1c1cad5e897c6390b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a5f4c7d4228495a3af02cad79b2ee7"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ab2a5f4c7d4228495a3af02cad79b2ee7">awe_audioExportSamples</a> (const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, void *outSamples, INT32 outStride, INT32 channel, <a class="el" href="a00056.html#a2148c107244f027b63ea5fa4e55a582b">SampleType</a> outType)</td></tr>
<tr class="memdesc:ab2a5f4c7d4228495a3af02cad79b2ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export samples to a user buffer from a channel.  <a href="a00044.html#ab2a5f4c7d4228495a3af02cad79b2ee7">More...</a><br /></td></tr>
<tr class="separator:ab2a5f4c7d4228495a3af02cad79b2ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b5a0f5f9f869fb6e7ebeccfdd8fae3"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#af4b5a0f5f9f869fb6e7ebeccfdd8fae3">awe_audioIsStarted</a> (const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE)</td></tr>
<tr class="memdesc:af4b5a0f5f9f869fb6e7ebeccfdd8fae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this instance is running.  <a href="a00044.html#af4b5a0f5f9f869fb6e7ebeccfdd8fae3">More...</a><br /></td></tr>
<tr class="separator:af4b5a0f5f9f869fb6e7ebeccfdd8fae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8882c4641a4461678acfab526f61478"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ab8882c4641a4461678acfab526f61478">awe_audioGetPumpMask</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE)</td></tr>
<tr class="memdesc:ab8882c4641a4461678acfab526f61478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if AWE is ready to run.  <a href="a00044.html#ab8882c4641a4461678acfab526f61478">More...</a><br /></td></tr>
<tr class="separator:ab8882c4641a4461678acfab526f61478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3df1d67abff15df3f81accf213a379"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#acb3df1d67abff15df3f81accf213a379">awe_audioIsReadyToPumpMulti</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 instanceID)</td></tr>
<tr class="memdesc:acb3df1d67abff15df3f81accf213a379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if AWE is ready to run on secondary instances (ID &gt; 0).  <a href="a00044.html#acb3df1d67abff15df3f81accf213a379">More...</a><br /></td></tr>
<tr class="separator:acb3df1d67abff15df3f81accf213a379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6569fd8a744cb20232e606643dfc54"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#acc6569fd8a744cb20232e606643dfc54">awe_audioStartPreemption</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, INT32 coreAffinity)</td></tr>
<tr class="memdesc:acc6569fd8a744cb20232e606643dfc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to correct overhead outside of the Audio Weaver, like Audio DMA ISR.  <a href="a00044.html#acc6569fd8a744cb20232e606643dfc54">More...</a><br /></td></tr>
<tr class="separator:acc6569fd8a744cb20232e606643dfc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05894753bc9b9f318d9a95218a03e94"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ac05894753bc9b9f318d9a95218a03e94">awe_audioEndPreemption</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 start_time, INT32 coreAffinity)</td></tr>
<tr class="memdesc:ac05894753bc9b9f318d9a95218a03e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to correct overhead outside of the Audio Weaver, like Audio DMA ISR.  <a href="a00044.html#ac05894753bc9b9f318d9a95218a03e94">More...</a><br /></td></tr>
<tr class="separator:ac05894753bc9b9f318d9a95218a03e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f78d537ec23c5222d4533de286f6349"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a2f78d537ec23c5222d4533de286f6349">awe_deferredSetCall</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE)</td></tr>
<tr class="memdesc:a2f78d537ec23c5222d4533de286f6349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform deferred awe set on a module.  <a href="a00044.html#a2f78d537ec23c5222d4533de286f6349">More...</a><br /></td></tr>
<tr class="separator:a2f78d537ec23c5222d4533de286f6349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1dea09d71a8da65f245174da6d594e"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#aab1dea09d71a8da65f245174da6d594e">awe_loadAWBfromArray</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, const UINT32 *pCommands, UINT32 arraySize, UINT32 *pPos)</td></tr>
<tr class="memdesc:aab1dea09d71a8da65f245174da6d594e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes packet commands from an in-memory array.  <a href="a00044.html#aab1dea09d71a8da65f245174da6d594e">More...</a><br /></td></tr>
<tr class="separator:aab1dea09d71a8da65f245174da6d594e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e1b4dbbf941d7e14dae2418223c3e7"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ad9e1b4dbbf941d7e14dae2418223c3e7">awe_loadAWBfromFile</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, const char *binaryFile, UINT32 *pPos)</td></tr>
<tr class="memdesc:ad9e1b4dbbf941d7e14dae2418223c3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load an AWB file from stdio.  <a href="a00044.html#ad9e1b4dbbf941d7e14dae2418223c3e7">More...</a><br /></td></tr>
<tr class="separator:ad9e1b4dbbf941d7e14dae2418223c3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c83934e6ab7efb1f21fc637de73468"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a08c83934e6ab7efb1f21fc637de73468">awe_loadAWBfromFlash</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, const char *binaryFile, UINT32 *pPos)</td></tr>
<tr class="memdesc:a08c83934e6ab7efb1f21fc637de73468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load an AWB file from the flash.  <a href="a00044.html#a08c83934e6ab7efb1f21fc637de73468">More...</a><br /></td></tr>
<tr class="separator:a08c83934e6ab7efb1f21fc637de73468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61771905f2f42ed871002d8114a79d09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a61771905f2f42ed871002d8114a79d09">awe_layoutGetChannelCount</a> (const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 pinIdx, UINT32 *inCount, UINT32 *outCount)</td></tr>
<tr class="memdesc:a61771905f2f42ed871002d8114a79d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of channels in the Layout's input and output pins.  <a href="a00044.html#a61771905f2f42ed871002d8114a79d09">More...</a><br /></td></tr>
<tr class="separator:a61771905f2f42ed871002d8114a79d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6de5a9c31b0a207bc43031e7ec23ed7"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ae6de5a9c31b0a207bc43031e7ec23ed7">awe_layoutGetInputBlockSize</a> (const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 pinIdx, UINT32 *blockSize)</td></tr>
<tr class="memdesc:ae6de5a9c31b0a207bc43031e7ec23ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the block size of a pin.  <a href="a00044.html#ae6de5a9c31b0a207bc43031e7ec23ed7">More...</a><br /></td></tr>
<tr class="separator:ae6de5a9c31b0a207bc43031e7ec23ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0069fd68edf24630c1c574835cdbd316"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a0069fd68edf24630c1c574835cdbd316">awe_layoutGetInputSampleRate</a> (const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 pinIdx, FLOAT32 *sampleRate)</td></tr>
<tr class="memdesc:a0069fd68edf24630c1c574835cdbd316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample rate of an input pin.  <a href="a00044.html#a0069fd68edf24630c1c574835cdbd316">More...</a><br /></td></tr>
<tr class="separator:a0069fd68edf24630c1c574835cdbd316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14f1cef3b4579e3d0aac85fe9a7c9cd"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#aa14f1cef3b4579e3d0aac85fe9a7c9cd">awe_layoutIsValid</a> (const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE)</td></tr>
<tr class="memdesc:aa14f1cef3b4579e3d0aac85fe9a7c9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a layout is loaded and valid.  <a href="a00044.html#aa14f1cef3b4579e3d0aac85fe9a7c9cd">More...</a><br /></td></tr>
<tr class="separator:aa14f1cef3b4579e3d0aac85fe9a7c9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292350a96704f17e8cd1ba3607b0d702"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a292350a96704f17e8cd1ba3607b0d702">awe_ctrlSetValue</a> (const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 handle, const void *value, INT32 arrayOffset, UINT32 length)</td></tr>
<tr class="memdesc:a292350a96704f17e8cd1ba3607b0d702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a scalar or array value of a module variable by handle.  <a href="a00044.html#a292350a96704f17e8cd1ba3607b0d702">More...</a><br /></td></tr>
<tr class="separator:a292350a96704f17e8cd1ba3607b0d702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53e394306aef852b52305bf638235bb"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#aa53e394306aef852b52305bf638235bb">awe_ctrlGetValue</a> (const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 handle, void *value, INT32 arrayOffset, UINT32 length)</td></tr>
<tr class="memdesc:aa53e394306aef852b52305bf638235bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a scalar or array value of a module variable by handle.  <a href="a00044.html#aa53e394306aef852b52305bf638235bb">More...</a><br /></td></tr>
<tr class="separator:aa53e394306aef852b52305bf638235bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d5b1802114a32413c9c6482eb995b0"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#aa3d5b1802114a32413c9c6482eb995b0">awe_ctrlSetStatus</a> (const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 handle, UINT32 status)</td></tr>
<tr class="memdesc:aa3d5b1802114a32413c9c6482eb995b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the runtime status of a module.  <a href="a00044.html#aa3d5b1802114a32413c9c6482eb995b0">More...</a><br /></td></tr>
<tr class="separator:aa3d5b1802114a32413c9c6482eb995b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2693d881f364d79d8f486ea8c884d09b"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a2693d881f364d79d8f486ea8c884d09b">awe_ctrlGetStatus</a> (const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 handle, UINT32 *status)</td></tr>
<tr class="memdesc:a2693d881f364d79d8f486ea8c884d09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the runtime status of a module.  <a href="a00044.html#a2693d881f364d79d8f486ea8c884d09b">More...</a><br /></td></tr>
<tr class="separator:a2693d881f364d79d8f486ea8c884d09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72dedbda062001d3b53369abd398c85"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ae72dedbda062001d3b53369abd398c85">awe_ctrlSetValueMask</a> (const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 handle, const void *value, INT32 arrayOffset, UINT32 length, UINT32 mask)</td></tr>
<tr class="memdesc:ae72dedbda062001d3b53369abd398c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a scalar or array value of a module variable by handle with mask.  <a href="a00044.html#ae72dedbda062001d3b53369abd398c85">More...</a><br /></td></tr>
<tr class="separator:ae72dedbda062001d3b53369abd398c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46f5a02752fa2ea9fb26691f3ad744d"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ae46f5a02752fa2ea9fb26691f3ad744d">awe_ctrlGetValueMask</a> (const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 handle, void *value, INT32 arrayOffset, UINT32 length, UINT32 mask)</td></tr>
<tr class="memdesc:ae46f5a02752fa2ea9fb26691f3ad744d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a scalar or array value of a module variable by handle with mask.  <a href="a00044.html#ae46f5a02752fa2ea9fb26691f3ad744d">More...</a><br /></td></tr>
<tr class="separator:ae46f5a02752fa2ea9fb26691f3ad744d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb38b521f683f62c7249a609f4a5bc4e"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#aeb38b521f683f62c7249a609f4a5bc4e">awe_ctrlGetModuleClass</a> (const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 handle, UINT32 *pClassID)</td></tr>
<tr class="memdesc:aeb38b521f683f62c7249a609f4a5bc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an object class from its handle.  <a href="a00044.html#aeb38b521f683f62c7249a609f4a5bc4e">More...</a><br /></td></tr>
<tr class="separator:aeb38b521f683f62c7249a609f4a5bc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a2989f2e5575d96ce9cd8baab99207"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#ac6a2989f2e5575d96ce9cd8baab99207">awe_setProfilingStatus</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 status)</td></tr>
<tr class="memdesc:ac6a2989f2e5575d96ce9cd8baab99207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the profiling ability of the AWE Core.  <a href="a00044.html#ac6a2989f2e5575d96ce9cd8baab99207">More...</a><br /></td></tr>
<tr class="separator:ac6a2989f2e5575d96ce9cd8baab99207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b94cd700b8db15b98c0386192efd50f"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a7b94cd700b8db15b98c0386192efd50f">awe_getAverageLayoutCycles</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, UINT32 layoutIdx, UINT32 *averageCycles)</td></tr>
<tr class="memdesc:a7b94cd700b8db15b98c0386192efd50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the average cycles of a running layout, in units of cycles at profileSpeed.  <a href="a00044.html#a7b94cd700b8db15b98c0386192efd50f">More...</a><br /></td></tr>
<tr class="separator:a7b94cd700b8db15b98c0386192efd50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd23e753a1360b0ec5112102ea5536f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a5fd23e753a1360b0ec5112102ea5536f">awe_setInstancesInfo</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> **pInstances, INT32 numAweInstancesOnCore)</td></tr>
<tr class="memdesc:a5fd23e753a1360b0ec5112102ea5536f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup function only intended for systems with multiple AWE Instances in a single core.  <a href="a00044.html#a5fd23e753a1360b0ec5112102ea5536f">More...</a><br /></td></tr>
<tr class="separator:a5fd23e753a1360b0ec5112102ea5536f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094bfa13c7a61ecee94cdf87e4c88390"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a094bfa13c7a61ecee94cdf87e4c88390">awe_fwSetLayoutCoreAffinity</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, INT32 layoutNumber, INT32 coreAffinity)</td></tr>
<tr class="memdesc:a094bfa13c7a61ecee94cdf87e4c88390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the core affinity of the layout in layoutNumber.  <a href="a00044.html#a094bfa13c7a61ecee94cdf87e4c88390">More...</a><br /></td></tr>
<tr class="separator:a094bfa13c7a61ecee94cdf87e4c88390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef98cd8c780d02cb9d88559cb28a390"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#abef98cd8c780d02cb9d88559cb28a390">awe_fwGetLayoutCoreAffinity</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, INT32 layoutNumber)</td></tr>
<tr class="memdesc:abef98cd8c780d02cb9d88559cb28a390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the core affinity of the layout in layoutNumber, initializes to 0 and can be set with awe_fwSetLayoutCoreAffinity.  <a href="a00044.html#abef98cd8c780d02cb9d88559cb28a390">More...</a><br /></td></tr>
<tr class="separator:abef98cd8c780d02cb9d88559cb28a390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b968559431299090c6c96e1e271ac15"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a3b968559431299090c6c96e1e271ac15">awe_getBuildVersionInfo</a> (<a class="el" href="a00044.html#ae753d7bd23dd29879d2732b0609cb4df">AWEBuildVersionInfo_t</a> *pBuildVersionInfo)</td></tr>
<tr class="memdesc:a3b968559431299090c6c96e1e271ac15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the AWECore build number and version information.  <a href="a00044.html#a3b968559431299090c6c96e1e271ac15">More...</a><br /></td></tr>
<tr class="separator:a3b968559431299090c6c96e1e271ac15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8524a801b0ee0750edb0bd842351a2d7"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html#a8524a801b0ee0750edb0bd842351a2d7">awe_setInstanceStandaloneAWBLoad</a> (<a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *pAWE, INT32 status)</td></tr>
<tr class="memdesc:a8524a801b0ee0750edb0bd842351a2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can be used to achieve Progressive Loading on a multi-instance system.  <a href="a00044.html#a8524a801b0ee0750edb0bd842351a2d7">More...</a><br /></td></tr>
<tr class="separator:a8524a801b0ee0750edb0bd842351a2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The AWEInstance API Header File. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="af3b70df7f9d672997e61999a024ba018" name="af3b70df7f9d672997e61999a024ba018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b70df7f9d672997e61999a024ba018">&#9670;&nbsp;</a></span>AWEInstance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a00071.html">_AWEInstance</a> <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The AWE instance. </p>
<p >The AWE Instance struct must have its members/pointers assigned at init time. The AWEInstance is the most important structure, and it must be initialized properly. After assigning all of the required members, the BSP author will call the awe_init() function. All members are required to be assigned unless they are marked optional in the detailed description below.. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae4e7e278a5a4794714190415899d8022" name="ae4e7e278a5a4794714190415899d8022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e7e278a5a4794714190415899d8022">&#9670;&nbsp;</a></span>awe_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the instance. </p>
<p >Call this once you have assigned all of the required members/pointers of the AWE Instance, and after calling awe_InitPin on both input and output pins. Calling awe_init before assigning all members of the instance structure or initializing the pins will result in crashes/erratic behavior. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAWE</td><td>instance to initialize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#a2dcafd624a5882e7aa32f22437f489b0">E_NULL_PACKET_BUFFER_POINTER</a>, <a class="el" href="a00047.html#a21cc3ea55f37b73d4476e9bf3e728ad9">E_NULL_REPLY_BUFFER_POINTER</a>, <a class="el" href="a00047.html#ad7041d57f6af2d687fde6f00250ad6a5">E_ZERO_PACKET_BUFFER_LENGTH</a>, <a class="el" href="a00047.html#a861a8a74eb5c703b3d95eb077d1431c4">E_EXCEPTION</a>, <a class="el" href="a00047.html#a81275887a08451a02c61ffe460523f93">E_PARAMETER_ERROR</a>, <a class="el" href="a00047.html#a49347015d537a757423ead16bf18e8d6">E_NOT_CREATED</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a24">ControlApp.c</a>, <a class="el" href="a00087.html#a35">LinuxApp.c</a>, <a class="el" href="a00088.html#a54">LinuxAppMulti.c</a>, <a class="el" href="a00085.html#a23">bare_metal_example.c</a>, and <a class="el" href="a00084.html#a26">singleinstance_simple.c</a>.</dd>
</dl>

</div>
</div>
<a id="a20d7c4aef91a7b0e190881efa67d15a7" name="a20d7c4aef91a7b0e190881efa67d15a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d7c4aef91a7b0e190881efa67d15a7">&#9670;&nbsp;</a></span>awe_initPin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_initPin </td>
          <td>(</td>
          <td class="paramtype">IOPinDescriptor *&#160;</td>
          <td class="paramname"><em>pPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an input or output pin. </p>
<p >This function must be called for both the input and output pins. Must be called BEFORE the awe_init API function. <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPin</td><td>the pin instance to initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channels</td><td>number of channels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>optional pin name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#af511f45608f85d7a97aafb917361f69b">E_NOT_OBJECT</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a23">ControlApp.c</a>, <a class="el" href="a00087.html#a34">LinuxApp.c</a>, <a class="el" href="a00088.html#a52">LinuxAppMulti.c</a>, <a class="el" href="a00085.html#a3">bare_metal_example.c</a>, and <a class="el" href="a00084.html#a25">singleinstance_simple.c</a>.</dd>
</dl>

</div>
</div>
<a id="a985924707ad2ac0c06eb792702783087" name="a985924707ad2ac0c06eb792702783087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985924707ad2ac0c06eb792702783087">&#9670;&nbsp;</a></span>awe_initFlashFS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void awe_initFlashFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00053.html#ae8ec7ae5a5cf8b4417f114378458ef3f">AWEFlashFSInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWEFlashFSInstance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the file system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAWE</td><td>instance to initialize </td></tr>
    <tr><td class="paramname">pAWEFlashFSInstance</td><td>the file system instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00088.html#a26">LinuxAppMulti.c</a>.</dd>
</dl>

</div>
</div>
<a id="ad4e9b6fa73ef4217ac60c80e7cb75b53" name="ad4e9b6fa73ef4217ac60c80e7cb75b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e9b6fa73ef4217ac60c80e7cb75b53">&#9670;&nbsp;</a></span>awe_packetProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_packetProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process an AWEInstance's newly received tuning packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>The AWE instance pointer to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error <a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#a7408d69943a661e439bcad654d392fca">E_COMMAND_NOT_IMPLEMENTED</a>, <a class="el" href="a00047.html#a97857d7d744f1565734333fb8ea4e9e4">E_MESSAGE_LENGTH_TOO_LONG</a>, <a class="el" href="a00047.html#ad8e3eea4434c0af23ec5f16eb46c72fe">E_CRC_ERROR</a>, <a class="el" href="a00047.html#a463c331236ba1fd458030dc94d1dec2e">E_BADPACKET</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00087.html#a3">LinuxApp.c</a>, <a class="el" href="a00085.html#a31">bare_metal_example.c</a>, and <a class="el" href="a00084.html#a3">singleinstance_simple.c</a>.</dd>
</dl>

</div>
</div>
<a id="a2d5438a02407ecb829c58faa4b2610f8" name="a2d5438a02407ecb829c58faa4b2610f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5438a02407ecb829c58faa4b2610f8">&#9670;&nbsp;</a></span>awe_packetProcessMulti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_packetProcessMulti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>isTuningInstance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-instance Wrapper for tuning packet processing. </p>
<p >If called by the tuning instance, call whenever a complete packet is received. Wait until the return value is not E_MULTI_PACKET_WAITING to forward reply back to the tuning interface. If called by a non-tuning instance, poll continuously in a low-priority task. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>The AWE instance pointer to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isTuningInstance</td><td>Boolean marking if the instance calling this API implements the tuning interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error <a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#ab4b51c99066bf10a1db260e1a53ec146">E_MULTI_PACKET_WAITING</a>, <a class="el" href="a00047.html#a7408d69943a661e439bcad654d392fca">E_COMMAND_NOT_IMPLEMENTED</a>, <br  />
 <a class="el" href="a00047.html#a97857d7d744f1565734333fb8ea4e9e4">E_MESSAGE_LENGTH_TOO_LONG</a>, <a class="el" href="a00047.html#ad8e3eea4434c0af23ec5f16eb46c72fe">E_CRC_ERROR</a>, <a class="el" href="a00047.html#a463c331236ba1fd458030dc94d1dec2e">E_BADPACKET</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00088.html#a4">LinuxAppMulti.c</a>.</dd>
</dl>

</div>
</div>
<a id="a3e08c72e3bf11627e4fd87a99ebb6419" name="a3e08c72e3bf11627e4fd87a99ebb6419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e08c72e3bf11627e4fd87a99ebb6419">&#9670;&nbsp;</a></span>awe_audioPump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_audioPump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>layoutIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Audio pump function. </p>
<p >Call this in your audio thread once you have imported the data you wish to process. Before pumping, you must also check that the AudioWeaver buffers have been filled (awe_getPumpMask) and that audio has been started (awe_audioIsStarted). This function will return 1 if awe_deferredSetCall needs to be called. This is for modules that need to do more time consuming calculations, like calculating filter coefficients. For example, a SOF Control module needs to calculate new coeffs when the frequency is modified by the control input. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>AWE instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layoutIndex</td><td>the layout index to pump </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#add9518a784e492932e165c600de0104f">E_NO_LAYOUTS</a>, or 1 (indicating that deferred set is needed, see documentation) </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a38">ControlApp.c</a>, <a class="el" href="a00087.html#a11">LinuxApp.c</a>, <a class="el" href="a00088.html#a13">LinuxAppMulti.c</a>, and <a class="el" href="a00085.html#a30">bare_metal_example.c</a>.</dd>
</dl>

</div>
</div>
<a id="a9e4bb98b017a47c1c1cad5e897c6390b" name="a9e4bb98b017a47c1c1cad5e897c6390b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4bb98b017a47c1c1cad5e897c6390b">&#9670;&nbsp;</a></span>awe_audioImportSamples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_audioImportSamples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>inSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>inStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00056.html#a2148c107244f027b63ea5fa4e55a582b">SampleType</a>&#160;</td>
          <td class="paramname"><em>inType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import samples from a user buffer to a channel. </p>
<p >The value of the fundamentalBlockSize member of the AWEInstance determines the number of samples that are imported with each call. Call this function once for each audio input channel on the hardware. Channel matching between hardware capabilities and layout will be done automatically. For example, if the target has only 1 audio input channel, and if a layout with 3 input channels is loaded, the second and third channels of the layout input will be all zeros. Inversely, if there are more HW input channels than the layout expects, then they are ignored.</p>
<p >The value of inStride defines the number of samples to skip between each read, and should be the number of interleaved channels in the inSamples buffer being read from. A typical usage for a single source, interleaved stereo input could look like: </p><div class="fragment"><div class="line"><a class="code hl_function" href="a00044.html#a9e4bb98b017a47c1c1cad5e897c6390b">awe_audioImportSamples</a>(pAWE, inSamples + 0, 2, 0, <a class="code hl_enumvalue" href="a00056.html#aa902d2fa9a96414950faa1cd33d02af9a8267a816f0e5d656471666befe047de3">Sample32bit</a>);</div>
<div class="line"><a class="code hl_function" href="a00044.html#a9e4bb98b017a47c1c1cad5e897c6390b">awe_audioImportSamples</a>(pAWE, inSamples + 1, 2, 1, <a class="code hl_enumvalue" href="a00056.html#aa902d2fa9a96414950faa1cd33d02af9a8267a816f0e5d656471666befe047de3">Sample32bit</a>);</div>
<div class="ttc" id="aa00044_html_a9e4bb98b017a47c1c1cad5e897c6390b"><div class="ttname"><a href="a00044.html#a9e4bb98b017a47c1c1cad5e897c6390b">awe_audioImportSamples</a></div><div class="ttdeci">INT32 awe_audioImportSamples(const AWEInstance *pAWE, const void *inSamples, INT32 inStride, INT32 channel, SampleType inType)</div><div class="ttdoc">Import samples from a user buffer to a channel.</div></div>
<div class="ttc" id="aa00056_html_aa902d2fa9a96414950faa1cd33d02af9a8267a816f0e5d656471666befe047de3"><div class="ttname"><a href="a00056.html#aa902d2fa9a96414950faa1cd33d02af9a8267a816f0e5d656471666befe047de3">Sample32bit</a></div><div class="ttdeci">@ Sample32bit</div><div class="ttdoc">Data is 32 bit PCM .</div><div class="ttdef"><b>Definition:</b> StandardDefs.h:231</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>AWE instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inSamples</td><td>pointer to first sample in buffer to import for current channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inStride</td><td>input buffer import stride </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>channel to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inType</td><td>type of input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#abbf2a17c41064b0e79d528745650375f">E_AUDIO_NOT_STARTED</a>, <a class="el" href="a00047.html#a81275887a08451a02c61ffe460523f93">E_PARAMETER_ERROR</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a35">ControlApp.c</a>, <a class="el" href="a00087.html#a8">LinuxApp.c</a>, <a class="el" href="a00088.html#a9">LinuxAppMulti.c</a>, and <a class="el" href="a00085.html#a26">bare_metal_example.c</a>.</dd>
</dl>

</div>
</div>
<a id="ab2a5f4c7d4228495a3af02cad79b2ee7" name="ab2a5f4c7d4228495a3af02cad79b2ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a5f4c7d4228495a3af02cad79b2ee7">&#9670;&nbsp;</a></span>awe_audioExportSamples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_audioExportSamples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>outStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00056.html#a2148c107244f027b63ea5fa4e55a582b">SampleType</a>&#160;</td>
          <td class="paramname"><em>outType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export samples to a user buffer from a channel. </p>
<p >The value of the fundamentalBlockSize member of the AWEInstance determines the number of samples that are exported with each call. Call this function once for each audio output channel on the hardware. Like awe_audioImportSamples, this will do channel matching automatically. For example, if the target has 3 audio output channels, and if a layout with 1 output channel is loaded, the second and third channels of the exported output will be all zeros. Inversely, if the layout has more output channels than the target supports, they are ignored.</p>
<p >The value of outStride defines the number of samples to skip between each write. It should be equal to the number of interleaved channels in the outSamples buffer being written to. A typical usage for exporting to an interleaved 3 channel output could look like: </p><div class="fragment"><div class="line"><a class="code hl_function" href="a00044.html#ab2a5f4c7d4228495a3af02cad79b2ee7">awe_audioExportSamples</a>(pAWE, &amp;outSamples[0], 3, 0, <a class="code hl_enumvalue" href="a00056.html#aa902d2fa9a96414950faa1cd33d02af9a8267a816f0e5d656471666befe047de3">Sample32bit</a>);</div>
<div class="line"><a class="code hl_function" href="a00044.html#ab2a5f4c7d4228495a3af02cad79b2ee7">awe_audioExportSamples</a>(pAWE, &amp;outSamples[1], 3, 1, <a class="code hl_enumvalue" href="a00056.html#aa902d2fa9a96414950faa1cd33d02af9a8267a816f0e5d656471666befe047de3">Sample32bit</a>);</div>
<div class="line"><a class="code hl_function" href="a00044.html#ab2a5f4c7d4228495a3af02cad79b2ee7">awe_audioExportSamples</a>(pAWE, &amp;outSamples[2], 3, 2, <a class="code hl_enumvalue" href="a00056.html#aa902d2fa9a96414950faa1cd33d02af9a8267a816f0e5d656471666befe047de3">Sample32bit</a>);</div>
<div class="ttc" id="aa00044_html_ab2a5f4c7d4228495a3af02cad79b2ee7"><div class="ttname"><a href="a00044.html#ab2a5f4c7d4228495a3af02cad79b2ee7">awe_audioExportSamples</a></div><div class="ttdeci">INT32 awe_audioExportSamples(const AWEInstance *pAWE, void *outSamples, INT32 outStride, INT32 channel, SampleType outType)</div><div class="ttdoc">Export samples to a user buffer from a channel.</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>AWE instance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outSamples</td><td>pointer to first sample in buffer to export to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outStride</td><td>output buffer export stride </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>channel to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outType</td><td>type of output data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#abbf2a17c41064b0e79d528745650375f">E_AUDIO_NOT_STARTED</a>, <a class="el" href="a00047.html#a81275887a08451a02c61ffe460523f93">E_PARAMETER_ERROR</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a39">ControlApp.c</a>, <a class="el" href="a00087.html#a13">LinuxApp.c</a>, <a class="el" href="a00088.html#a15">LinuxAppMulti.c</a>, and <a class="el" href="a00085.html#a29">bare_metal_example.c</a>.</dd>
</dl>

</div>
</div>
<a id="af4b5a0f5f9f869fb6e7ebeccfdd8fae3" name="af4b5a0f5f9f869fb6e7ebeccfdd8fae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b5a0f5f9f869fb6e7ebeccfdd8fae3">&#9670;&nbsp;</a></span>awe_audioIsStarted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_audioIsStarted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if this instance is running. </p>
<p >A BSP author can use this to determine if the instance is already running to avoid pumping audio through a dead layout. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAWE</td><td>instance pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if audio is not started, 1 if audio is started. No error conditions </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a29">ControlApp.c</a>, <a class="el" href="a00087.html#a7">LinuxApp.c</a>, <a class="el" href="a00088.html#a8">LinuxAppMulti.c</a>, and <a class="el" href="a00085.html#a24">bare_metal_example.c</a>.</dd>
</dl>

</div>
</div>
<a id="ab8882c4641a4461678acfab526f61478" name="ab8882c4641a4461678acfab526f61478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8882c4641a4461678acfab526f61478">&#9670;&nbsp;</a></span>awe_audioGetPumpMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_audioGetPumpMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if AWE is ready to run. </p>
<p >This will return the "layout mask" which is a bit vector of threads to run. For a simple, single threaded system, the bitvector will be 0x1. If a previous pump is not complete and the layout is ready to pump again, an overflow is detected by this function. In this condition, the layoutMask bit for the overflowed layout will be zero, which prevents the layout from being pumped again. Example: int layoutMask = awe_audioGetPumpMask(&amp;g_AWEInstance); if (layoutMask &gt; 0) { if (layoutMask &amp; 0x1) { int ret = awe_audioPump(&amp;g_AWEInstance, 0); } } </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAWE</td><td>AWE instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bit vector of threads to run, 0 if no threads, <a class="el" href="a00047.html#abbf2a17c41064b0e79d528745650375f">E_AUDIO_NOT_STARTED</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a37">ControlApp.c</a>, <a class="el" href="a00087.html#a10">LinuxApp.c</a>, <a class="el" href="a00088.html#a11">LinuxAppMulti.c</a>, and <a class="el" href="a00085.html#a28">bare_metal_example.c</a>.</dd>
</dl>

</div>
</div>
<a id="acb3df1d67abff15df3f81accf213a379" name="acb3df1d67abff15df3f81accf213a379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3df1d67abff15df3f81accf213a379">&#9670;&nbsp;</a></span>awe_audioIsReadyToPumpMulti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_audioIsReadyToPumpMulti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>instanceID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if AWE is ready to run on secondary instances (ID &gt; 0). </p>
<p >This must be used in multi-instance applications to determine when to trigger secondary instances. Failure to do so can result in pumping at the wrong rates. This avoids unneccessary interrupts on secondary instances where layout block size is higher than the fundamental block size. This function returns TRUE or FALSE. When it returns TRUE, corresponding secondary instance is ready to signal. When this function is called with instance ID 0 or invalid ID, then always False is returned. Example: int pumpSlaveInstance = awe_audioIsReadyToPumpMulti(&amp;g_AWEInstance, 1); if (pumpSlaveInstance) { Signal slave core to get pump mask raise(); } </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAWE</td><td>AWE instance </td></tr>
    <tr><td class="paramname">instanceID</td><td>AWE instance ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00088.html#a12">LinuxAppMulti.c</a>.</dd>
</dl>

</div>
</div>
<a id="acc6569fd8a744cb20232e606643dfc54" name="acc6569fd8a744cb20232e606643dfc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6569fd8a744cb20232e606643dfc54">&#9670;&nbsp;</a></span>awe_audioStartPreemption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 awe_audioStartPreemption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>coreAffinity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to correct overhead outside of the Audio Weaver, like Audio DMA ISR. </p>
<p >Call this function at the very beginning of the DMA ISR and store the returned value, which is an argument to following end function call. For the use case where multiple instances exists on the same core, this function can be called with any instance's AWEInstance pointer, provided that the user called <a class="el" href="a00044.html#a5fd23e753a1360b0ec5112102ea5536f">awe_setInstancesInfo</a> during the startup. Example: UINT32 start_time = awe_audioStartPreemption(&amp;g_AWEInstance, coreAffinity);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAWE</td><td>AWE instance </td></tr>
    <tr><td class="paramname">coreAffinity</td><td>Core affinity from which this function is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>start time stamp in cycles at profiling clock </dd></dl>

</div>
</div>
<a id="ac05894753bc9b9f318d9a95218a03e94" name="ac05894753bc9b9f318d9a95218a03e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05894753bc9b9f318d9a95218a03e94">&#9670;&nbsp;</a></span>awe_audioEndPreemption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 awe_audioEndPreemption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>start_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>coreAffinity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to correct overhead outside of the Audio Weaver, like Audio DMA ISR. </p>
<p >Call this function at the end in the DMA ISR with start_time returned by awe_audioStartPreemption(). If the DMA ISR has low latency audio pump calls, then this function must be called before the audio pump and call awe_audioStartPreemption() again after pump. Note that the funtion awe_audioStartPreemption() must be called first, before calling awe_audioEndPreemption(). For the use case where multiple instances exists on the same core, this function can be called with any instance's AWEInstance pointer, provided that the user called <a class="el" href="a00044.html#a5fd23e753a1360b0ec5112102ea5536f">awe_setInstancesInfo</a> during the startup. Example: awe_audioEndPreemption(&amp;g_AWEInstance, start_time, coreAffinity);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAWE</td><td>AWE instance </td></tr>
    <tr><td class="paramname">start_time</td><td>Start time returned by the corresponding start function "awe_audioStartPreemption" </td></tr>
    <tr><td class="paramname">coreAffinity</td><td>Core affinity from which this function is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elapsed time between start preempt and this function </dd></dl>

</div>
</div>
<a id="a2f78d537ec23c5222d4533de286f6349" name="a2f78d537ec23c5222d4533de286f6349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f78d537ec23c5222d4533de286f6349">&#9670;&nbsp;</a></span>awe_deferredSetCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_deferredSetCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform deferred awe set on a module. </p>
<p >Each call to awe_deferredSetCall processes a single module. Usually this function would be called repeatedly until the return value is 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>AWE instance pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>finishedProcessing Will return 1 when processing is incomplete, 0 when complete. No error codes. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00087.html#a12">LinuxApp.c</a>, <a class="el" href="a00088.html#a14">LinuxAppMulti.c</a>, and <a class="el" href="a00085.html#a32">bare_metal_example.c</a>.</dd>
</dl>

</div>
</div>
<a id="aab1dea09d71a8da65f245174da6d594e" name="aab1dea09d71a8da65f245174da6d594e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1dea09d71a8da65f245174da6d594e">&#9670;&nbsp;</a></span>awe_loadAWBfromArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_loadAWBfromArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UINT32 *&#160;</td>
          <td class="paramname"><em>pCommands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>arraySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32 *&#160;</td>
          <td class="paramname"><em>pPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes packet commands from an in-memory array. </p>
<p >Designer can generate AWB arrays directly from a layout. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>AWE instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCommands</td><td>Buffer with commands to execute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arraySize</td><td>Number of DWords in command buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pPos</td><td>Report failing word index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a> <a class="el" href="a00047.html#a861a8a74eb5c703b3d95eb077d1431c4">E_EXCEPTION</a> <a class="el" href="a00047.html#ae894f8b2238be0ebaf153ff3dbdff578">E_UNEXPECTED_EOF</a> <a class="el" href="a00047.html#abc7eff8f20bd01775cfeb299f8a1f151">E_END_OF_FILE</a> <a class="el" href="a00047.html#a97857d7d744f1565734333fb8ea4e9e4">E_MESSAGE_LENGTH_TOO_LONG</a> <a class="el" href="a00047.html#a463c331236ba1fd458030dc94d1dec2e">E_BADPACKET</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a26">ControlApp.c</a>, and <a class="el" href="a00088.html#a57">LinuxAppMulti.c</a>.</dd>
</dl>

</div>
</div>
<a id="ad9e1b4dbbf941d7e14dae2418223c3e7" name="ad9e1b4dbbf941d7e14dae2418223c3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e1b4dbbf941d7e14dae2418223c3e7">&#9670;&nbsp;</a></span>awe_loadAWBfromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_loadAWBfromFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>binaryFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32 *&#160;</td>
          <td class="paramname"><em>pPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load an AWB file from stdio. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>AWE instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binaryFile</td><td>AWB file to be loaded </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pPos</td><td>Report failing word index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a> <a class="el" href="a00047.html#a861a8a74eb5c703b3d95eb077d1431c4">E_EXCEPTION</a> <a class="el" href="a00047.html#ae894f8b2238be0ebaf153ff3dbdff578">E_UNEXPECTED_EOF</a> <a class="el" href="a00047.html#abc7eff8f20bd01775cfeb299f8a1f151">E_END_OF_FILE</a> <a class="el" href="a00047.html#a97857d7d744f1565734333fb8ea4e9e4">E_MESSAGE_LENGTH_TOO_LONG</a> <a class="el" href="a00047.html#a463c331236ba1fd458030dc94d1dec2e">E_BADPACKET</a> <a class="el" href="a00047.html#a042c26c6906f6e3833ba175ca0a6f267">E_CANTOPEN</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00087.html#a46">LinuxApp.c</a>.</dd>
</dl>

</div>
</div>
<a id="a08c83934e6ab7efb1f21fc637de73468" name="a08c83934e6ab7efb1f21fc637de73468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c83934e6ab7efb1f21fc637de73468">&#9670;&nbsp;</a></span>awe_loadAWBfromFlash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_loadAWBfromFlash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>binaryFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32 *&#160;</td>
          <td class="paramname"><em>pPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load an AWB file from the flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>AWE instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binaryFile</td><td>AWB file to be loaded </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pPos</td><td>Report failing word index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a> <a class="el" href="a00047.html#a861a8a74eb5c703b3d95eb077d1431c4">E_EXCEPTION</a> <a class="el" href="a00047.html#ae894f8b2238be0ebaf153ff3dbdff578">E_UNEXPECTED_EOF</a> <a class="el" href="a00047.html#abc7eff8f20bd01775cfeb299f8a1f151">E_END_OF_FILE</a> <a class="el" href="a00047.html#a97857d7d744f1565734333fb8ea4e9e4">E_MESSAGE_LENGTH_TOO_LONG</a> <a class="el" href="a00047.html#a463c331236ba1fd458030dc94d1dec2e">E_BADPACKET</a> <a class="el" href="a00047.html#a042c26c6906f6e3833ba175ca0a6f267">E_CANTOPEN</a> </dd></dl>

</div>
</div>
<a id="a61771905f2f42ed871002d8114a79d09" name="a61771905f2f42ed871002d8114a79d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61771905f2f42ed871002d8114a79d09">&#9670;&nbsp;</a></span>awe_layoutGetChannelCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void awe_layoutGetChannelCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>pinIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32 *&#160;</td>
          <td class="paramname"><em>inCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32 *&#160;</td>
          <td class="paramname"><em>outCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of channels in the Layout's input and output pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>AWE instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pinIdx</td><td>which input pin (always 0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inCount</td><td>channels in primary input pin </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outCount</td><td>channels in primary output pin </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a30">ControlApp.c</a>.</dd>
</dl>

</div>
</div>
<a id="ae6de5a9c31b0a207bc43031e7ec23ed7" name="ae6de5a9c31b0a207bc43031e7ec23ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6de5a9c31b0a207bc43031e7ec23ed7">&#9670;&nbsp;</a></span>awe_layoutGetInputBlockSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_layoutGetInputBlockSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>pinIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32 *&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the block size of a pin. </p>
<p >Because the block size of the output pin is inherited from the input pin, the user only needs to check the input pin. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>The AWE Instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pinIdx</td><td>which input pin (always 0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">blockSize</td><td>block size of input pin </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#add9518a784e492932e165c600de0104f">E_NO_LAYOUTS</a>, <a class="el" href="a00047.html#a521c7cbef3e5666daea1e55fbb6a44eb">E_PIN_ID_NOT_FOUND</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a31">ControlApp.c</a>.</dd>
</dl>

</div>
</div>
<a id="a0069fd68edf24630c1c574835cdbd316" name="a0069fd68edf24630c1c574835cdbd316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0069fd68edf24630c1c574835cdbd316">&#9670;&nbsp;</a></span>awe_layoutGetInputSampleRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_layoutGetInputSampleRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>pinIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLOAT32 *&#160;</td>
          <td class="paramname"><em>sampleRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sample rate of an input pin. </p>
<p >Because the sample rate of the output pin is inherited from the input pin, the user only needs to check the input pin. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>The AWE Instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pinIdx</td><td>which input pin (always 0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sampleRate</td><td>the input pin sample rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#add9518a784e492932e165c600de0104f">E_NO_LAYOUTS</a>, <a class="el" href="a00047.html#a521c7cbef3e5666daea1e55fbb6a44eb">E_PIN_ID_NOT_FOUND</a> </dd></dl>

</div>
</div>
<a id="aa14f1cef3b4579e3d0aac85fe9a7c9cd" name="aa14f1cef3b4579e3d0aac85fe9a7c9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14f1cef3b4579e3d0aac85fe9a7c9cd">&#9670;&nbsp;</a></span>awe_layoutIsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_layoutIsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a layout is loaded and valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>The AWE Instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if layout is not valid/loaded, 1 if layout is valid. No error codes. <br  />
 </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a28">ControlApp.c</a>, <a class="el" href="a00087.html#a6">LinuxApp.c</a>, <a class="el" href="a00088.html#a7">LinuxAppMulti.c</a>, and <a class="el" href="a00085.html#a25">bare_metal_example.c</a>.</dd>
</dl>

</div>
</div>
<a id="a292350a96704f17e8cd1ba3607b0d702" name="a292350a96704f17e8cd1ba3607b0d702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292350a96704f17e8cd1ba3607b0d702">&#9670;&nbsp;</a></span>awe_ctrlSetValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_ctrlSetValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>arrayOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a scalar or array value of a module variable by handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>packed object handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value(s) to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayOffset</td><td>array index if array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>number of elements. 1 if scaler </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#afb0f622e946e94288723bcf949af3d2c">E_ARGUMENT_ERROR</a>, <a class="el" href="a00047.html#a8530f4175bd66c81cdec7c3d2fdee3ff">E_BAD_MEMBER_INDEX</a>, <a class="el" href="a00047.html#a52e2c1c4fe79fc60bf9f48e8c9000e4f">E_CLASS_NOT_SUPPORTED</a>, <a class="el" href="a00047.html#a7c4b0435408c6db98cdbccdcd0a2ac73">E_LINKEDLIST_CORRUPT</a>, <a class="el" href="a00047.html#a567f879996835164b8cddea33277a1b0">E_NO_MORE_OBJECTS</a> <br  />
 </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a33">ControlApp.c</a>, and <a class="el" href="a00085.html#a35">bare_metal_example.c</a>.</dd>
</dl>

</div>
</div>
<a id="aa53e394306aef852b52305bf638235bb" name="aa53e394306aef852b52305bf638235bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53e394306aef852b52305bf638235bb">&#9670;&nbsp;</a></span>awe_ctrlGetValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_ctrlGetValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>arrayOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a scalar or array value of a module variable by handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>packed object handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>value(s) to get </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayOffset</td><td>array index if array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>number of elements. 1 if scaler </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#afb0f622e946e94288723bcf949af3d2c">E_ARGUMENT_ERROR</a>, <a class="el" href="a00047.html#a8530f4175bd66c81cdec7c3d2fdee3ff">E_BAD_MEMBER_INDEX</a>, <a class="el" href="a00047.html#a52e2c1c4fe79fc60bf9f48e8c9000e4f">E_CLASS_NOT_SUPPORTED</a>, <a class="el" href="a00047.html#a7c4b0435408c6db98cdbccdcd0a2ac73">E_LINKEDLIST_CORRUPT</a>, <a class="el" href="a00047.html#a567f879996835164b8cddea33277a1b0">E_NO_MORE_OBJECTS</a> <br  />
 </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a34">ControlApp.c</a>, and <a class="el" href="a00085.html#a34">bare_metal_example.c</a>.</dd>
</dl>

</div>
</div>
<a id="aa3d5b1802114a32413c9c6482eb995b0" name="aa3d5b1802114a32413c9c6482eb995b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d5b1802114a32413c9c6482eb995b0">&#9670;&nbsp;</a></span>awe_ctrlSetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_ctrlSetStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the runtime status of a module. </p>
<p >0 = Active, 1 = Bypass, 2 = Mute, 3 = Inactive </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>packed object handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>status to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#a3f1cc8d557e6f7071866ba13dc98d3b6">E_NOT_MODULE</a>, <a class="el" href="a00047.html#a7c4b0435408c6db98cdbccdcd0a2ac73">E_LINKEDLIST_CORRUPT</a>, <a class="el" href="a00047.html#a567f879996835164b8cddea33277a1b0">E_NO_MORE_OBJECTS</a> </dd></dl>

</div>
</div>
<a id="a2693d881f364d79d8f486ea8c884d09b" name="a2693d881f364d79d8f486ea8c884d09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2693d881f364d79d8f486ea8c884d09b">&#9670;&nbsp;</a></span>awe_ctrlGetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_ctrlGetStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32 *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the runtime status of a module. </p>
<p >0 = Active, 1 = Bypass, 2 = Mute, 3 = Inactive </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>packed object handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>pointer to return status value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#a3f1cc8d557e6f7071866ba13dc98d3b6">E_NOT_MODULE</a>, <a class="el" href="a00047.html#a7c4b0435408c6db98cdbccdcd0a2ac73">E_LINKEDLIST_CORRUPT</a>, <a class="el" href="a00047.html#a567f879996835164b8cddea33277a1b0">E_NO_MORE_OBJECTS</a>, <a class="el" href="a00047.html#a81275887a08451a02c61ffe460523f93">E_PARAMETER_ERROR</a> </dd></dl>

</div>
</div>
<a id="ae72dedbda062001d3b53369abd398c85" name="ae72dedbda062001d3b53369abd398c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72dedbda062001d3b53369abd398c85">&#9670;&nbsp;</a></span>awe_ctrlSetValueMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_ctrlSetValueMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>arrayOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a scalar or array value of a module variable by handle with mask. </p>
<p >A mask allows you to only call module's set function for a single variable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>packed object handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value(s) to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayOffset</td><td>array index if array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>number of elements if array. 1 if scaler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>mask to use - 0 to not call set function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#afb0f622e946e94288723bcf949af3d2c">E_ARGUMENT_ERROR</a>, <a class="el" href="a00047.html#a8530f4175bd66c81cdec7c3d2fdee3ff">E_BAD_MEMBER_INDEX</a>, <a class="el" href="a00047.html#a52e2c1c4fe79fc60bf9f48e8c9000e4f">E_CLASS_NOT_SUPPORTED</a>, <a class="el" href="a00047.html#af5349ac502102237fa2bda73981d947d">E_OBJECT_ID_NOT_FOUND</a>, <a class="el" href="a00047.html#a3f1cc8d557e6f7071866ba13dc98d3b6">E_NOT_MODULE</a> <br  />
 </dd></dl>

</div>
</div>
<a id="ae46f5a02752fa2ea9fb26691f3ad744d" name="ae46f5a02752fa2ea9fb26691f3ad744d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46f5a02752fa2ea9fb26691f3ad744d">&#9670;&nbsp;</a></span>awe_ctrlGetValueMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_ctrlGetValueMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>arrayOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a scalar or array value of a module variable by handle with mask. </p>
<p >A mask allows you to only call module's set function for a single variable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>packed object handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>value(s) to get </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayOffset</td><td>array index if array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>number of elements if array. 1 if scaler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>mask to use - 0 to not call get function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#afb0f622e946e94288723bcf949af3d2c">E_ARGUMENT_ERROR</a>, <a class="el" href="a00047.html#a8530f4175bd66c81cdec7c3d2fdee3ff">E_BAD_MEMBER_INDEX</a>, <a class="el" href="a00047.html#a52e2c1c4fe79fc60bf9f48e8c9000e4f">E_CLASS_NOT_SUPPORTED</a>, <a class="el" href="a00047.html#af5349ac502102237fa2bda73981d947d">E_OBJECT_ID_NOT_FOUND</a>, <a class="el" href="a00047.html#a3f1cc8d557e6f7071866ba13dc98d3b6">E_NOT_MODULE</a> <br  />
 </dd></dl>

</div>
</div>
<a id="aeb38b521f683f62c7249a609f4a5bc4e" name="aeb38b521f683f62c7249a609f4a5bc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb38b521f683f62c7249a609f4a5bc4e">&#9670;&nbsp;</a></span>awe_ctrlGetModuleClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_ctrlGetModuleClass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32 *&#160;</td>
          <td class="paramname"><em>pClassID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an object class from its handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pAWE</td><td>instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>handle of object to find </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pClassID</td><td>pointer to found object class </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#a567f879996835164b8cddea33277a1b0">E_NO_MORE_OBJECTS</a>, <a class="el" href="a00047.html#a7c4b0435408c6db98cdbccdcd0a2ac73">E_LINKEDLIST_CORRUPT</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a32">ControlApp.c</a>, and <a class="el" href="a00085.html#a33">bare_metal_example.c</a>.</dd>
</dl>

</div>
</div>
<a id="ac6a2989f2e5575d96ce9cd8baab99207" name="ac6a2989f2e5575d96ce9cd8baab99207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a2989f2e5575d96ce9cd8baab99207">&#9670;&nbsp;</a></span>awe_setProfilingStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_setProfilingStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the profiling ability of the AWE Core. </p>
<p >Both top and module level profiling and preemption overhead correction enabled by default at awe_init. Use this function if you wish to selectively enable or disable per pump profiling during runtime. Disabling profiling saves a small amount of cycles per pump. User can also enable or disable independently module level profiling and top level profiling and overhead correction due to preemption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAWE</td><td>instance pointer </td></tr>
    <tr><td class="paramname">status</td><td>0 to disable both, 1 to enable both, 2 to enable module level only, 3 to enable top level only, 4 to enable preemption overhead correction and 5 to disable preemption overhead correction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#af511f45608f85d7a97aafb917361f69b">E_NOT_OBJECT</a>, <a class="el" href="a00047.html#a81275887a08451a02c61ffe460523f93">E_PARAMETER_ERROR</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a25">ControlApp.c</a>, <a class="el" href="a00087.html#a36">LinuxApp.c</a>, and <a class="el" href="a00088.html#a55">LinuxAppMulti.c</a>.</dd>
</dl>

</div>
</div>
<a id="a7b94cd700b8db15b98c0386192efd50f" name="a7b94cd700b8db15b98c0386192efd50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b94cd700b8db15b98c0386192efd50f">&#9670;&nbsp;</a></span>awe_getAverageLayoutCycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_getAverageLayoutCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>layoutIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32 *&#160;</td>
          <td class="paramname"><em>averageCycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the average cycles of a running layout, in units of cycles at profileSpeed. </p>
<p >Returns cycles in 24.8 format, so shift right by 8 bits for integer value. To get CPU cycles, multiply by target cpuSpeed / profileSpeed. If a previous pump is not complete and the layout is ready to pump again, an overflow is detected. When in this state, the awe_getAverageLayoutCycles api will return the averageCycles = AWE_PUMP_OVF_MAX_AVG_CYCLES (0xFFFFFFFF). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAWE</td><td>instance pointer </td></tr>
    <tr><td class="paramname">layoutIdx</td><td>Layout index (typically 0, except in advanced use cases) </td></tr>
    <tr><td class="paramname">averageCycles</td><td>Pointer the output (average layout cycles) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00047.html#ad1a31c5316d5f51ca5c1c4fb2b9b1958">E_SUCCESS</a>, <a class="el" href="a00047.html#a81275887a08451a02c61ffe460523f93">E_PARAMETER_ERROR</a>, <a class="el" href="a00047.html#add9518a784e492932e165c600de0104f">E_NO_LAYOUTS</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00088.html#a16">LinuxAppMulti.c</a>.</dd>
</dl>

</div>
</div>
<a id="a5fd23e753a1360b0ec5112102ea5536f" name="a5fd23e753a1360b0ec5112102ea5536f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd23e753a1360b0ec5112102ea5536f">&#9670;&nbsp;</a></span>awe_setInstancesInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void awe_setInstancesInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> **&#160;</td>
          <td class="paramname"><em>pInstances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>numAweInstancesOnCore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup function only intended for systems with multiple AWE Instances in a single core. </p>
<p >Call this function at startup after awe_init is done in the sequence. Enables both accurate profiling and loading of multi-instance designs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pInstances</td><td>Array of AWE Instance pointers that process on one core. Array must <br  />
 exist as long as the system is active. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numAweInstancesOnCore</td><td>Number of AWE Instances in pInstances array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00088.html#a56">LinuxAppMulti.c</a>.</dd>
</dl>

</div>
</div>
<a id="a094bfa13c7a61ecee94cdf87e4c88390" name="a094bfa13c7a61ecee94cdf87e4c88390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094bfa13c7a61ecee94cdf87e4c88390">&#9670;&nbsp;</a></span>awe_fwSetLayoutCoreAffinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_fwSetLayoutCoreAffinity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>layoutNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>coreAffinity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the core affinity of the layout in layoutNumber. </p>
<p >Used to get more accurate profiling in multithreaded systems. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>AWE instance pointer (this) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layoutNumber</td><td>the layout index to set the core affinity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coreAffinity</td><td>core affinity to set in the layout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>E_SUCCESS or E_INVALID_LAYOUT_INDEX if no layout </dd></dl>

</div>
</div>
<a id="abef98cd8c780d02cb9d88559cb28a390" name="abef98cd8c780d02cb9d88559cb28a390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef98cd8c780d02cb9d88559cb28a390">&#9670;&nbsp;</a></span>awe_fwGetLayoutCoreAffinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_fwGetLayoutCoreAffinity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>layoutNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the core affinity of the layout in layoutNumber, initializes to 0 and can be set with awe_fwSetLayoutCoreAffinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>AWE instance pointer (this) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layoutNumber</td><td>the layout index to get the core affinity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the core affinity of the requested layout, or E_INVALID_LAYOUT_INDEX if no layout </dd></dl>

</div>
</div>
<a id="a3b968559431299090c6c96e1e271ac15" name="a3b968559431299090c6c96e1e271ac15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b968559431299090c6c96e1e271ac15">&#9670;&nbsp;</a></span>awe_getBuildVersionInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_getBuildVersionInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#ae753d7bd23dd29879d2732b0609cb4df">AWEBuildVersionInfo_t</a> *&#160;</td>
          <td class="paramname"><em>pBuildVersionInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the AWECore build number and version information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pBuildVersionInfo</td><td>Pointer of type AWEBuildVersionInfo_t to return build version information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return E_SUCCESS up on success. If pBuildVersionInfo is NULL, E_NOT_OBJECT returned. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00087.html#a39">LinuxApp.c</a>.</dd>
</dl>

</div>
</div>
<a id="a8524a801b0ee0750edb0bd842351a2d7" name="a8524a801b0ee0750edb0bd842351a2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8524a801b0ee0750edb0bd842351a2d7">&#9670;&nbsp;</a></span>awe_setInstanceStandaloneAWBLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 awe_setInstanceStandaloneAWBLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html#af3b70df7f9d672997e61999a024ba018">AWEInstance</a> *&#160;</td>
          <td class="paramname"><em>pAWE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function can be used to achieve Progressive Loading on a multi-instance system. </p>
<p >Indicates this instance loads AWB in standalone mode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAWE</td><td>AWE instance pointer (this) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Boolean flag indicates to enable or disable standalone loading. 1 - to enable standalone mode, 0 - to disable standalone mode. Default disabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>E_NO_HEAP_MEMORY if no shared memory exists and E_SUCCESS otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
