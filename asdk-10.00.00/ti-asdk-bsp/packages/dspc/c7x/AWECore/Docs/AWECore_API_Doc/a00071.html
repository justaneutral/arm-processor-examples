<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AWE Core 8.X.0 Documentation: _AWEInstance Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AWE Core 8.X.0 Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle"><div class="title">_AWEInstance Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The AWE instance.  
 <a href="a00071.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00044_source.html">Include/AWEInstance.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ae9532b2425c362e352c24f11c8edd02a"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae9532b2425c362e352c24f11c8edd02a">instanceId</a></td></tr>
<tr class="memdesc:ae9532b2425c362e352c24f11c8edd02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ID of this instance.  <a href="a00071.html#ae9532b2425c362e352c24f11c8edd02a">More...</a><br /></td></tr>
<tr class="separator:ae9532b2425c362e352c24f11c8edd02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbeef773c955bfda318ca134fa40f03b"><td class="memItemLeft" align="right" valign="top">UINT32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#afbeef773c955bfda318ca134fa40f03b">pFastHeapA</a></td></tr>
<tr class="memdesc:afbeef773c955bfda318ca134fa40f03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast heap A.  <a href="a00071.html#afbeef773c955bfda318ca134fa40f03b">More...</a><br /></td></tr>
<tr class="separator:afbeef773c955bfda318ca134fa40f03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3357ea97cbc3a98ffff830eb586dca32"><td class="memItemLeft" align="right" valign="top"><a id="a3357ea97cbc3a98ffff830eb586dca32" name="a3357ea97cbc3a98ffff830eb586dca32"></a>
UINT32 *&#160;</td><td class="memItemRight" valign="bottom"><b>pFastHeapB</b></td></tr>
<tr class="memdesc:a3357ea97cbc3a98ffff830eb586dca32"><td class="mdescLeft">&#160;</td><td class="mdescRight">The second fast heap, B . <br /></td></tr>
<tr class="separator:a3357ea97cbc3a98ffff830eb586dca32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19cf0c2c0ae9511cfe3625d3f2df53b"><td class="memItemLeft" align="right" valign="top"><a id="aa19cf0c2c0ae9511cfe3625d3f2df53b" name="aa19cf0c2c0ae9511cfe3625d3f2df53b"></a>
UINT32 *&#160;</td><td class="memItemRight" valign="bottom"><b>pSlowHeap</b></td></tr>
<tr class="memdesc:aa19cf0c2c0ae9511cfe3625d3f2df53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The slow heap. <br /></td></tr>
<tr class="separator:aa19cf0c2c0ae9511cfe3625d3f2df53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a2203871c4688499180f87429e3d76"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#af4a2203871c4688499180f87429e3d76">fastHeapASize</a></td></tr>
<tr class="memdesc:af4a2203871c4688499180f87429e3d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fast heap A size in 32-bit words.  <a href="a00071.html#af4a2203871c4688499180f87429e3d76">More...</a><br /></td></tr>
<tr class="separator:af4a2203871c4688499180f87429e3d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5c50b58381b039a7e2044863ba9444"><td class="memItemLeft" align="right" valign="top"><a id="acc5c50b58381b039a7e2044863ba9444" name="acc5c50b58381b039a7e2044863ba9444"></a>
UINT32&#160;</td><td class="memItemRight" valign="bottom"><b>fastHeapBSize</b></td></tr>
<tr class="memdesc:acc5c50b58381b039a7e2044863ba9444"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fast heap B size. <br /></td></tr>
<tr class="separator:acc5c50b58381b039a7e2044863ba9444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c37e96abcd68926d0ac6959b5dc6cd6"><td class="memItemLeft" align="right" valign="top"><a id="a8c37e96abcd68926d0ac6959b5dc6cd6" name="a8c37e96abcd68926d0ac6959b5dc6cd6"></a>
UINT32&#160;</td><td class="memItemRight" valign="bottom"><b>slowHeapSize</b></td></tr>
<tr class="memdesc:a8c37e96abcd68926d0ac6959b5dc6cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The slow heap size. <br /></td></tr>
<tr class="separator:a8c37e96abcd68926d0ac6959b5dc6cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6422edfaf98b2c9d2b8e4d61503862c3"><td class="memItemLeft" align="right" valign="top">INT32(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a6422edfaf98b2c9d2b8e4d61503862c3">cbAudioStart</a> )(struct <a class="el" href="a00071.html">_AWEInstance</a> *PAWE)</td></tr>
<tr class="memdesc:a6422edfaf98b2c9d2b8e4d61503862c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPTIONAL This callback is invoked when a layout is run or when a StartAudio command is sent.  <a href="a00071.html#a6422edfaf98b2c9d2b8e4d61503862c3">More...</a><br /></td></tr>
<tr class="separator:a6422edfaf98b2c9d2b8e4d61503862c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689ac9ee605eeb9517ccfaa15679e71a"><td class="memItemLeft" align="right" valign="top">INT32(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a689ac9ee605eeb9517ccfaa15679e71a">cbAudioStop</a> )(struct <a class="el" href="a00071.html">_AWEInstance</a> *pAWE)</td></tr>
<tr class="memdesc:a689ac9ee605eeb9517ccfaa15679e71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPTIONAL.  <a href="a00071.html#a689ac9ee605eeb9517ccfaa15679e71a">More...</a><br /></td></tr>
<tr class="separator:a689ac9ee605eeb9517ccfaa15679e71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14040b49d721c77d015a633acc6cc4cc"><td class="memItemLeft" align="right" valign="top">INT32(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a14040b49d721c77d015a633acc6cc4cc">cbCacheInvalidate</a> )(struct <a class="el" href="a00071.html">_AWEInstance</a> *pAWE, void *nStartingAddress, UINT32 lengthInWords)</td></tr>
<tr class="memdesc:a14040b49d721c77d015a633acc6cc4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPTIONAL This callback is invoked wherever cache flush or invalidation is required, either in the framework or in modules.  <a href="a00071.html#a14040b49d721c77d015a633acc6cc4cc">More...</a><br /></td></tr>
<tr class="separator:a14040b49d721c77d015a633acc6cc4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7eb5b8ffacc6c6fc82fbcf0ed55a108"><td class="memItemLeft" align="right" valign="top">INT32(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae7eb5b8ffacc6c6fc82fbcf0ed55a108">cbGetLayoutThreadPriority</a> )(struct <a class="el" href="a00071.html">_AWEInstance</a> *pAWE, INT32 layoutNum)</td></tr>
<tr class="memdesc:ae7eb5b8ffacc6c6fc82fbcf0ed55a108"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPTIONAL This callback is invoked from a module which is going to split the internal processing into multiple parallel threads at the same thread priority as the layout priority.  <a href="a00071.html#ae7eb5b8ffacc6c6fc82fbcf0ed55a108">More...</a><br /></td></tr>
<tr class="separator:ae7eb5b8ffacc6c6fc82fbcf0ed55a108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b44d860ec9755b807ff1c1e5769fbd"><td class="memItemLeft" align="right" valign="top"><a id="a04b44d860ec9755b807ff1c1e5769fbd" name="a04b44d860ec9755b807ff1c1e5769fbd"></a>
IOPinDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><b>pInputPin</b></td></tr>
<tr class="memdesc:a04b44d860ec9755b807ff1c1e5769fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BSP author must define/allocate an input pin in their BSP and assign it to this member NOTE: AudioWeaver only supports single input/output pins, so the pin must have only ONE element Example: static IOPinDescriptor s_InputPin[1];. <br /></td></tr>
<tr class="separator:a04b44d860ec9755b807ff1c1e5769fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5612d068da07ac3f25cf34126b0c3ee1"><td class="memItemLeft" align="right" valign="top"><a id="a5612d068da07ac3f25cf34126b0c3ee1" name="a5612d068da07ac3f25cf34126b0c3ee1"></a>
IOPinDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><b>pOutputPin</b></td></tr>
<tr class="memdesc:a5612d068da07ac3f25cf34126b0c3ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BSP author must define/allocate an output pin in their BSP and assign it to this member NOTE: AudioWeaver only supports single input/output pins, so the pin must have only ONE element Example: static IOPinDescriptor s_OutputPin[1];. <br /></td></tr>
<tr class="separator:a5612d068da07ac3f25cf34126b0c3ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7e2d3cb5d35f9704d968e489c4c441"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#aeb7e2d3cb5d35f9704d968e489c4c441">numModules</a></td></tr>
<tr class="memdesc:aeb7e2d3cb5d35f9704d968e489c4c441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of modules in module table.  <a href="a00071.html#aeb7e2d3cb5d35f9704d968e489c4c441">More...</a><br /></td></tr>
<tr class="separator:aeb7e2d3cb5d35f9704d968e489c4c441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ff1dcacc3c9cc819b6f956ce79cf3f"><td class="memItemLeft" align="right" valign="top">const ModClassModule **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#af1ff1dcacc3c9cc819b6f956ce79cf3f">pModuleDescriptorTable</a></td></tr>
<tr class="memdesc:af1ff1dcacc3c9cc819b6f956ce79cf3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to module table.  <a href="a00071.html#af1ff1dcacc3c9cc819b6f956ce79cf3f">More...</a><br /></td></tr>
<tr class="separator:af1ff1dcacc3c9cc819b6f956ce79cf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b01cf1b8e8a280bbf3f7f948f54f74b"><td class="memItemLeft" align="right" valign="top">UINT32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a5b01cf1b8e8a280bbf3f7f948f54f74b">pPacketBuffer</a></td></tr>
<tr class="memdesc:a5b01cf1b8e8a280bbf3f7f948f54f74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Packet buffer pointer.  <a href="a00071.html#a5b01cf1b8e8a280bbf3f7f948f54f74b">More...</a><br /></td></tr>
<tr class="separator:a5b01cf1b8e8a280bbf3f7f948f54f74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af7c6f45a9ea471031950713dc8a58d"><td class="memItemLeft" align="right" valign="top">UINT32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a2af7c6f45a9ea471031950713dc8a58d">pReplyBuffer</a></td></tr>
<tr class="memdesc:a2af7c6f45a9ea471031950713dc8a58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reply buffer pointer.  <a href="a00071.html#a2af7c6f45a9ea471031950713dc8a58d">More...</a><br /></td></tr>
<tr class="separator:a2af7c6f45a9ea471031950713dc8a58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab625b95dee9149bb1eae3ff92eb53b2f"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ab625b95dee9149bb1eae3ff92eb53b2f">packetBufferSize</a></td></tr>
<tr class="memdesc:ab625b95dee9149bb1eae3ff92eb53b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packet buffer size.  <a href="a00071.html#ab625b95dee9149bb1eae3ff92eb53b2f">More...</a><br /></td></tr>
<tr class="separator:ab625b95dee9149bb1eae3ff92eb53b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b76eb4a2bd9153d87b0a4081e6cdc0"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#aa2b76eb4a2bd9153d87b0a4081e6cdc0">userVersion</a></td></tr>
<tr class="memdesc:aa2b76eb4a2bd9153d87b0a4081e6cdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">User Version word.  <a href="a00071.html#aa2b76eb4a2bd9153d87b0a4081e6cdc0">More...</a><br /></td></tr>
<tr class="separator:aa2b76eb4a2bd9153d87b0a4081e6cdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae805783687d93c111f2803d6b07c7d05"><td class="memItemLeft" align="right" valign="top"><a id="ae805783687d93c111f2803d6b07c7d05" name="ae805783687d93c111f2803d6b07c7d05"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>coreSpeed</b></td></tr>
<tr class="memdesc:ae805783687d93c111f2803d6b07c7d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BSP author will set this to the speed of the CPU they are integrating into. <br /></td></tr>
<tr class="separator:ae805783687d93c111f2803d6b07c7d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c40d7469bcb0c0b30c35d27ab7a9fb2"><td class="memItemLeft" align="right" valign="top"><a id="a1c40d7469bcb0c0b30c35d27ab7a9fb2" name="a1c40d7469bcb0c0b30c35d27ab7a9fb2"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>profileSpeed</b></td></tr>
<tr class="memdesc:a1c40d7469bcb0c0b30c35d27ab7a9fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Profiling clock speed in Hz. <br /></td></tr>
<tr class="separator:a1c40d7469bcb0c0b30c35d27ab7a9fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147fe9ce7dca2b6bcc3d86ac9b36f025"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a147fe9ce7dca2b6bcc3d86ac9b36f025">pName</a></td></tr>
<tr class="memdesc:a147fe9ce7dca2b6bcc3d86ac9b36f025"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the AWE Instance that will be displayed in Server.  <a href="a00071.html#a147fe9ce7dca2b6bcc3d86ac9b36f025">More...</a><br /></td></tr>
<tr class="separator:a147fe9ce7dca2b6bcc3d86ac9b36f025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440826c61772cf568281332f76871954"><td class="memItemLeft" align="right" valign="top"><a id="a440826c61772cf568281332f76871954" name="a440826c61772cf568281332f76871954"></a>
UINT32&#160;</td><td class="memItemRight" valign="bottom"><b>numThreads</b></td></tr>
<tr class="memdesc:a440826c61772cf568281332f76871954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of threads supported for multithreaded systems(1-4). <br /></td></tr>
<tr class="separator:a440826c61772cf568281332f76871954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69aad6195a0f3fec1e6affcd613b027"><td class="memItemLeft" align="right" valign="top"><a id="aa69aad6195a0f3fec1e6affcd613b027" name="aa69aad6195a0f3fec1e6affcd613b027"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>sampleRate</b></td></tr>
<tr class="memdesc:aa69aad6195a0f3fec1e6affcd613b027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default sample rate of this instance. <br /></td></tr>
<tr class="separator:aa69aad6195a0f3fec1e6affcd613b027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb2adbcdae20532abb84c0c7fc9e318"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#a9cb2adbcdae20532abb84c0c7fc9e318">fundamentalBlockSize</a></td></tr>
<tr class="memdesc:a9cb2adbcdae20532abb84c0c7fc9e318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base frame size of this instance.  <a href="a00071.html#a9cb2adbcdae20532abb84c0c7fc9e318">More...</a><br /></td></tr>
<tr class="separator:a9cb2adbcdae20532abb84c0c7fc9e318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae210f0425f22de96f25bf36ab14ba88c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00053.html#ae8ec7ae5a5cf8b4417f114378458ef3f">AWEFlashFSInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ae210f0425f22de96f25bf36ab14ba88c">pFlashFileSystem</a></td></tr>
<tr class="memdesc:ae210f0425f22de96f25bf36ab14ba88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">DSPC Flash file system instance.  <a href="a00071.html#ae210f0425f22de96f25bf36ab14ba88c">More...</a><br /></td></tr>
<tr class="separator:ae210f0425f22de96f25bf36ab14ba88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f2f163ae5569e16a4a99070037741c"><td class="memItemLeft" align="right" valign="top">volatile UINT32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ab8f2f163ae5569e16a4a99070037741c">pSharedHeap</a></td></tr>
<tr class="memdesc:ab8f2f163ae5569e16a4a99070037741c"><td class="mdescLeft">&#160;</td><td class="mdescRight">AWE Core shared memory definitions.  <a href="a00071.html#ab8f2f163ae5569e16a4a99070037741c">More...</a><br /></td></tr>
<tr class="separator:ab8f2f163ae5569e16a4a99070037741c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ea51f58db3b9d03151fde8bb03574f"><td class="memItemLeft" align="right" valign="top"><a id="ae0ea51f58db3b9d03151fde8bb03574f" name="ae0ea51f58db3b9d03151fde8bb03574f"></a>
UINT32&#160;</td><td class="memItemRight" valign="bottom"><b>sharedHeapSize</b></td></tr>
<tr class="memdesc:ae0ea51f58db3b9d03151fde8bb03574f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The shared heap size, in 32-bit words. <br /></td></tr>
<tr class="separator:ae0ea51f58db3b9d03151fde8bb03574f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade74518284efdb8fa9e28ea53c832b94"><td class="memItemLeft" align="right" valign="top"><a id="ade74518284efdb8fa9e28ea53c832b94" name="ade74518284efdb8fa9e28ea53c832b94"></a>
UINT32&#160;</td><td class="memItemRight" valign="bottom"><b>numProcessingInstances</b></td></tr>
<tr class="memdesc:ade74518284efdb8fa9e28ea53c832b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of audio processing instances of AWE Core configured on a single target. <br /></td></tr>
<tr class="separator:ade74518284efdb8fa9e28ea53c832b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad364f83a25bdf9bf870a892501e1a7af"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html#ad364f83a25bdf9bf870a892501e1a7af">_Reserved</a> [301]</td></tr>
<tr class="memdesc:ad364f83a25bdf9bf870a892501e1a7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal members.  <a href="a00071.html#ad364f83a25bdf9bf870a892501e1a7af">More...</a><br /></td></tr>
<tr class="separator:ad364f83a25bdf9bf870a892501e1a7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The AWE instance. </p>
<p >The AWE Instance struct must have its members/pointers assigned at init time. The AWEInstance is the most important structure, and it must be initialized properly. After assigning all of the required members, the BSP author will call the awe_init() function. All members are required to be assigned unless they are marked optional in the detailed description below.. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#_a0">ControlApp.c</a>, <a class="el" href="a00087.html#_a0">LinuxApp.c</a>, <a class="el" href="a00088.html#_a0">LinuxAppMulti.c</a>, <a class="el" href="a00085.html#_a0">bare_metal_example.c</a>, and <a class="el" href="a00084.html#_a0">singleinstance_simple.c</a>.</dd>
</dl>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="ae9532b2425c362e352c24f11c8edd02a" name="ae9532b2425c362e352c24f11c8edd02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9532b2425c362e352c24f11c8edd02a">&#9670;&nbsp;</a></span>instanceId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 _AWEInstance::instanceId</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The ID of this instance. </p>
<p >Single instance systems should always be 0. The instanceID of the AWEInstance must match the instanceID of your desired AWE commands. For example, if your packet router is routing commands to this instance with an address of 16, the instance's instanceID must be 16. See Packet Routing pseudocode above </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00088.html#a6">LinuxAppMulti.c</a>, <a class="el" href="a00085.html#a5">bare_metal_example.c</a>, and <a class="el" href="a00084.html#a4">singleinstance_simple.c</a>.</dd>
</dl>

</div>
</div>
<a id="afbeef773c955bfda318ca134fa40f03b" name="afbeef773c955bfda318ca134fa40f03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbeef773c955bfda318ca134fa40f03b">&#9670;&nbsp;</a></span>pFastHeapA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32* _AWEInstance::pFastHeapA</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast heap A. </p>
<p >This is the main heap. AWE heaps are user allocated memory required by the AWE Instance. <br  />
 </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a15">ControlApp.c</a>, <a class="el" href="a00087.html#a26">LinuxApp.c</a>, <a class="el" href="a00088.html#a40">LinuxAppMulti.c</a>, <a class="el" href="a00085.html#a17">bare_metal_example.c</a>, and <a class="el" href="a00084.html#a19">singleinstance_simple.c</a>.</dd>
</dl>

</div>
</div>
<a id="af4a2203871c4688499180f87429e3d76" name="af4a2203871c4688499180f87429e3d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a2203871c4688499180f87429e3d76">&#9670;&nbsp;</a></span>fastHeapASize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 _AWEInstance::fastHeapASize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The fast heap A size in 32-bit words. </p>
<p >Heap sizes will vary from platform to platform, and also depend on the size of a layout. A good place to start for each heap is 1048576, however this will be too large for some platforms. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a12">ControlApp.c</a>, <a class="el" href="a00087.html#a23">LinuxApp.c</a>, <a class="el" href="a00088.html#a36">LinuxAppMulti.c</a>, <a class="el" href="a00085.html#a14">bare_metal_example.c</a>, and <a class="el" href="a00084.html#a16">singleinstance_simple.c</a>.</dd>
</dl>

</div>
</div>
<a id="a6422edfaf98b2c9d2b8e4d61503862c3" name="a6422edfaf98b2c9d2b8e4d61503862c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6422edfaf98b2c9d2b8e4d61503862c3">&#9670;&nbsp;</a></span>cbAudioStart</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32(* _AWEInstance::cbAudioStart) (struct <a class="el" href="a00071.html">_AWEInstance</a> *PAWE)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OPTIONAL This callback is invoked when a layout is run or when a StartAudio command is sent. </p>
<p >A user will define their own callback function and initialize this member with a pointer to their function. This callback can be used for whatever the BSP author pleases, including configuring audio devices based on layout properties, etc.. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a18">ControlApp.c</a>, <a class="el" href="a00087.html#a29">LinuxApp.c</a>, and <a class="el" href="a00088.html#a48">LinuxAppMulti.c</a>.</dd>
</dl>

</div>
</div>
<a id="a689ac9ee605eeb9517ccfaa15679e71a" name="a689ac9ee605eeb9517ccfaa15679e71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689ac9ee605eeb9517ccfaa15679e71a">&#9670;&nbsp;</a></span>cbAudioStop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32(* _AWEInstance::cbAudioStop) (struct <a class="el" href="a00071.html">_AWEInstance</a> *pAWE)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OPTIONAL. </p>
<p >This callback is invoked when a layout is stopped or a StopAudio command is sent A user will define their own callback function and init this member with a pointer to their function. This callback can also be used for whatever the BSP author pleases, including halting audio streams, freeing buffers, etc... </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a19">ControlApp.c</a>, <a class="el" href="a00087.html#a30">LinuxApp.c</a>, and <a class="el" href="a00088.html#a49">LinuxAppMulti.c</a>.</dd>
</dl>

</div>
</div>
<a id="a14040b49d721c77d015a633acc6cc4cc" name="a14040b49d721c77d015a633acc6cc4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14040b49d721c77d015a633acc6cc4cc">&#9670;&nbsp;</a></span>cbCacheInvalidate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32(* _AWEInstance::cbCacheInvalidate) (struct <a class="el" href="a00071.html">_AWEInstance</a> *pAWE, void *nStartingAddress, UINT32 lengthInWords)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OPTIONAL This callback is invoked wherever cache flush or invalidation is required, either in the framework or in modules. </p>
<p >This callback is useful in the FFSWrapper where the FFS bin file stored in L2/L3 RAM. The callback is also useful for Multi Instance environments where the shared heap is allocated in a cached region. The callback function expects two arguments; the start address of the memory to be invalidated, and length in 32-bit words. </p>

</div>
</div>
<a id="ae7eb5b8ffacc6c6fc82fbcf0ed55a108" name="ae7eb5b8ffacc6c6fc82fbcf0ed55a108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7eb5b8ffacc6c6fc82fbcf0ed55a108">&#9670;&nbsp;</a></span>cbGetLayoutThreadPriority</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32(* _AWEInstance::cbGetLayoutThreadPriority) (struct <a class="el" href="a00071.html">_AWEInstance</a> *pAWE, INT32 layoutNum)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OPTIONAL This callback is invoked from a module which is going to split the internal processing into multiple parallel threads at the same thread priority as the layout priority. </p>
<p >BSP is responsible to return the thread priority of the layoutNum. </p>

</div>
</div>
<a id="aeb7e2d3cb5d35f9704d968e489c4c441" name="aeb7e2d3cb5d35f9704d968e489c4c441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7e2d3cb5d35f9704d968e489c4c441">&#9670;&nbsp;</a></span>numModules</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 _AWEInstance::numModules</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of modules in module table. </p>
<p >This can be manually set, or it can be determined by getting the size of the module descriptor table. Example: UINT32 module_descriptor_table_size = sizeof(g_module_descriptor_table) / sizeof(g_module_descriptor_table[0]); AWEInstance1.numModules = module_descriptor_table_size; </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a7">ControlApp.c</a>, <a class="el" href="a00087.html#a18">LinuxApp.c</a>, <a class="el" href="a00088.html#a32">LinuxAppMulti.c</a>, <a class="el" href="a00085.html#a11">bare_metal_example.c</a>, and <a class="el" href="a00084.html#a11">singleinstance_simple.c</a>.</dd>
</dl>

</div>
</div>
<a id="af1ff1dcacc3c9cc819b6f956ce79cf3f" name="af1ff1dcacc3c9cc819b6f956ce79cf3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ff1dcacc3c9cc819b6f956ce79cf3f">&#9670;&nbsp;</a></span>pModuleDescriptorTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ModClassModule** _AWEInstance::pModuleDescriptorTable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to module table. </p>
<p >The module table is the list of modules that will be included in the instance. See the provided "ModuleList.h" header for syntax specifics. Any set of available modules can be included/excluded from the instance by simply adding or removing them from the table. Note: this is often used for reducing the memory usage in production. AudioWeaver Designer can generate a ModuleList.h from a layout that ONLY includes the modules used in that layout. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a6">ControlApp.c</a>, <a class="el" href="a00087.html#a17">LinuxApp.c</a>, <a class="el" href="a00088.html#a31">LinuxAppMulti.c</a>, <a class="el" href="a00085.html#a10">bare_metal_example.c</a>, and <a class="el" href="a00084.html#a10">singleinstance_simple.c</a>.</dd>
</dl>

</div>
</div>
<a id="a5b01cf1b8e8a280bbf3f7f948f54f74b" name="a5b01cf1b8e8a280bbf3f7f948f54f74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b01cf1b8e8a280bbf3f7f948f54f74b">&#9670;&nbsp;</a></span>pPacketBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32* _AWEInstance::pPacketBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Packet buffer pointer. </p>
<p >A BSP author must allocate a buffer of length packetBufferSize and set pPacketBuffer to the address of that buffer. Example: g_AWEInstance.packetBufferSize = packetBufferSize; UINT32 AWE_Packet_Buffer[g_AWEInstance.packetBufferSize]; g_AWEInstance.pPacketBuffer = AWE_Packet_Buffer; </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a3">ControlApp.c</a>, <a class="el" href="a00087.html#a1">LinuxApp.c</a>, <a class="el" href="a00088.html#a28">LinuxAppMulti.c</a>, <a class="el" href="a00085.html#a20">bare_metal_example.c</a>, and <a class="el" href="a00084.html#a7">singleinstance_simple.c</a>.</dd>
</dl>

</div>
</div>
<a id="a2af7c6f45a9ea471031950713dc8a58d" name="a2af7c6f45a9ea471031950713dc8a58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af7c6f45a9ea471031950713dc8a58d">&#9670;&nbsp;</a></span>pReplyBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32* _AWEInstance::pReplyBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reply buffer pointer. </p>
<p >Initialized the same way as pPacketBuffer. The pPacketBuffer will be processed and the reply will be inserted into pReplyBuffer. Example: g_AWEInstance.packetBufferSize = packetBufferSize; UINT32 AWE_Reply_Buffer[g_AWEInstance.packetBufferSize]; g_AWEInstance.pReplyBuffer = AWE_Reply_Buffer; <br  />
 </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a4">ControlApp.c</a>, <a class="el" href="a00087.html#a5">LinuxApp.c</a>, <a class="el" href="a00088.html#a29">LinuxAppMulti.c</a>, <a class="el" href="a00085.html#a21">bare_metal_example.c</a>, and <a class="el" href="a00084.html#a8">singleinstance_simple.c</a>.</dd>
</dl>

</div>
</div>
<a id="ab625b95dee9149bb1eae3ff92eb53b2f" name="ab625b95dee9149bb1eae3ff92eb53b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab625b95dee9149bb1eae3ff92eb53b2f">&#9670;&nbsp;</a></span>packetBufferSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 _AWEInstance::packetBufferSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packet buffer size. </p>
<p >Must be initialized to the size of the BSP's packet buffers. The recommended packet buffer size is 264 32-bit words. If you need to use a smaller packetBufferSize due to memory constraints on your target, please contact DSPC Engineering. (The absolute minimum packetBufferSize is 16 and absolute max is 4105) </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a5">ControlApp.c</a>, <a class="el" href="a00087.html#a16">LinuxApp.c</a>, <a class="el" href="a00088.html#a30">LinuxAppMulti.c</a>, <a class="el" href="a00085.html#a22">bare_metal_example.c</a>, and <a class="el" href="a00084.html#a9">singleinstance_simple.c</a>.</dd>
</dl>

</div>
</div>
<a id="aa2b76eb4a2bd9153d87b0a4081e6cdc0" name="aa2b76eb4a2bd9153d87b0a4081e6cdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b76eb4a2bd9153d87b0a4081e6cdc0">&#9670;&nbsp;</a></span>userVersion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 _AWEInstance::userVersion</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User Version word. </p>
<p >A BSP author can initialize this to any UINT32 value they would like. Should mean something to the BSP author, but no required meaning/syntax. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00085.html#a4">bare_metal_example.c</a>.</dd>
</dl>

</div>
</div>
<a id="a147fe9ce7dca2b6bcc3d86ac9b36f025" name="a147fe9ce7dca2b6bcc3d86ac9b36f025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147fe9ce7dca2b6bcc3d86ac9b36f025">&#9670;&nbsp;</a></span>pName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* _AWEInstance::pName</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The name of the AWE Instance that will be displayed in Server. </p>
<p >Can be any 8 character string Name of this instance as a string <br  />
 </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a22">ControlApp.c</a>, <a class="el" href="a00087.html#a33">LinuxApp.c</a>, <a class="el" href="a00088.html#a46">LinuxAppMulti.c</a>, <a class="el" href="a00085.html#a8">bare_metal_example.c</a>, and <a class="el" href="a00084.html#a24">singleinstance_simple.c</a>.</dd>
</dl>

</div>
</div>
<a id="a9cb2adbcdae20532abb84c0c7fc9e318" name="a9cb2adbcdae20532abb84c0c7fc9e318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb2adbcdae20532abb84c0c7fc9e318">&#9670;&nbsp;</a></span>fundamentalBlockSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 _AWEInstance::fundamentalBlockSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base frame size of this instance. </p>
<p >In order for a layout to run on an instance, it must be a multiple of the fundamental blocksize </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a10">ControlApp.c</a>, <a class="el" href="a00087.html#a21">LinuxApp.c</a>, <a class="el" href="a00088.html#a35">LinuxAppMulti.c</a>, <a class="el" href="a00085.html#a13">bare_metal_example.c</a>, and <a class="el" href="a00084.html#a14">singleinstance_simple.c</a>.</dd>
</dl>

</div>
</div>
<a id="ae210f0425f22de96f25bf36ab14ba88c" name="ae210f0425f22de96f25bf36ab14ba88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae210f0425f22de96f25bf36ab14ba88c">&#9670;&nbsp;</a></span>pFlashFileSystem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00053.html#ae8ec7ae5a5cf8b4417f114378458ef3f">AWEFlashFSInstance</a>* _AWEInstance::pFlashFileSystem</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DSPC Flash file system instance. </p>
<p >OPTIONAL if no FFS. If implementing the optional flash file system, then assign this pointer to your properly initialized flash file system instance </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00086.html#a11">ControlApp.c</a>, <a class="el" href="a00087.html#a22">LinuxApp.c</a>, <a class="el" href="a00088.html#a27">LinuxAppMulti.c</a>, and <a class="el" href="a00084.html#a15">singleinstance_simple.c</a>.</dd>
</dl>

</div>
</div>
<a id="ab8f2f163ae5569e16a4a99070037741c" name="ab8f2f163ae5569e16a4a99070037741c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f2f163ae5569e16a4a99070037741c">&#9670;&nbsp;</a></span>pSharedHeap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile UINT32* _AWEInstance::pSharedHeap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AWE Core shared memory definitions. </p>
<p >Not required if using only single-instance AWE Core The shared heap. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="a00088.html#a43">LinuxAppMulti.c</a>.</dd>
</dl>

</div>
</div>
<a id="ad364f83a25bdf9bf870a892501e1a7af" name="ad364f83a25bdf9bf870a892501e1a7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad364f83a25bdf9bf870a892501e1a7af">&#9670;&nbsp;</a></span>_Reserved</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 _AWEInstance::_Reserved[301]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal members. </p>
<p >Reserved memory. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Include/<a class="el" href="a00044_source.html">AWEInstance.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
